# 4-5 C#의 클래스 확장
클래스, 캡슐화, 상속, 다형성을 구현하는 것으로 C# 언어가 객체지향 언어라고 말할 수는 있지만 현실 세계에서 프로그래밍하려면 좀 더 다양한 요소가 필요하다. 

## 1. 타입 유형 확장 
지금까지 현실 세계의 다양한 객체를 class 구문을 이용해 프로그래밍 세계의 타입으로 구현해 봤다. 얼핏 생각해 보면 여기서 배운 class 만으로도 모든 구문을 표현할 수 있다고 자신할 수 있겠지만 프로그래밍하다 보면 좀 더 다양한 유형이 필요하다는 것을 깨닫게 된다.

### 1-1 중첩 클래스
중첩 클래스(nested class)는 클래스 내부에 또 다른 클래스를 정의하는 것이다. 그런데 그런 경우가 정말 필요할까? 예를 들어, 하드디스크를 생각해 보자. 하드 디스크는 내부에 플래터(platter)라고 하는 원형 금속판을 여러 개 포함하고 있으며, 헤드(head)가 그 금속판 위에 데이터를 읽고 쓰는 동작을 수행한다. 플래터와 헤드는 다른 구성 요소에 재사용되기보다는 하드 디스크 전용으로 내장되는 것이 일반적이다. 그런데도 각 요소를 클래스로 나누어 정의하면 플래터와 헤드가 다른 클래스에서 사용되는 것을 막을 수 없다. 자칫 개발자로 하여금 실수할 여지가 남아 있게 되는 것이다. 
<br>

class의 경우 접근 제한자를 생략하면 기본적으로 internal이 지정된다고 설명한 바 있다. 하지만 중첩 클래스의 경우 접근 제한자가 생략되면 다른 멤버와 마찬가지로 pricate이 지정되어 외부에서 인스턴스를 직접 생성하는 것이 불가능해진다. 중첩 클래스를 외부에서 사용하고 싶다면 명시적으로 public 접근 제한자를 지정해야 한다. 
<br>

### 1-2 추상 클래스
앞에서 설명한 메서드 오버라이드는 일반적으로 virtual 메서드를 정의한 부모 클래스에서 그에 대한 기본적인 기능을 구현하고, 자식 클래스에서는 override 예약어를 이용해 그 기능을 재정의 한다. 또한 부모 클래스와 자식 클래스 모두 new를 이용해 인스턴스를 생성하는 것이 가능하다. 그런데 때로는 부모 클래스의 인스턴스를 생성하지 못하게 하면서 특정 메서드에 대해 자식들이 반드시 재정의 하도록 강제하고 싶을 수 있다. 추상 클래스와 추상 메서드는 그와 같은 상황을 위해 존재한다. 
<br>

여기서 두 가지 새로운 개념이 나왔다. 우선 추상메서드는 abstract 예약어가 지정되고 구현 코드가 없는 메서드를 말한다. 추상 메서드는 일반 클래스에 존재할 수 없으며, 반드시 추상 클래스 안에서만 선언할 수 있다. abstract 예약어가 지정된 추상 메서드를 다른 말로 쉽게 정의하자면 "코드 없는 가상 메서드(virtual method)" 라고 이해하면 된다
<br>

> 추상 메서드에는 접근 제한자로 private을 지정할 수 없다. 추상 메서드는 반드시 자식 클래스에서 재정의 해야 한다는 점을 감안해 보면 이를 상식적으로 이해할 수 있다.
<br>

추상 클래스는 abstract 예약어가 지정돼 있다는 점을 제외하면 일반 클래스 정의와 완전히 동일하다. 이 예약어로 인해 일반 클래스와 차별화되는 점은 1) new를 사용해 인스턴스로 만들 수 없다는 것과 2) 추상 메서드를 가질 수 있다는 것뿐이다.
<br>

추상 메서드는 가상 메서드에 속하기 때문에 자식 클래스에서 override 예약어를 사용해 재정의한다. 당연히 가상 메서드이므로 다형성의 특징이 그대로 적용된다.
<br>

물론코드가 비어 있는 가상 메서드와 일반 클래스의 조합으로 정의해도 무방하다. 단지 가상 메서드는 자식 클래스에서 재정의 하지 않아도 컴파일할 때 오류가 발생하지 않지만 추상 클래스의 추상 메서드는 자식 클래스에서 반드시 재정의해야만 컴파일된다. 즉, 컴파일 단계에서부터 재정의를 강제하고 싶을 때 유용하게 사용할 수 있는 것이 바로 추상 클래스와 추상 메서드다. 

### 1-3 델리게이트
지금까지 배운 것처럼 타입은 "값"을 담을 수 있다. 그렇다면 그 "값"의 범위에 "메서드"도 포함될 수 있지 않을까? 
<br>

이렇게 메서드를 가리킬 수 있는 타입을 C#에서는 특별히 델리게이트(delegate)라는 구문으로 제공한다. 그런데 델리게이트 타입을 만드는 방법은 일반적인 class 구문이 아니고 delegate라는 예약어로 표현한다.

> __접근제한자 delegate 대상_메서드의_반환타입 식별자(.... 대상_메서드의 _매개변수_목록)__ <br>
대상이 될 메서드의 반환 타입 및 매개변수 목록과 일치하는 델리게이트 타입을 정의한다. 참고로 C/C++ 개발자에게는 델리게이트를 간단하게 함수 포인터라고 설명한다.
<br>

얼핏 보면 델리게이트를 정의하는 방법이 다소 어려울 수 있는데, 차근차근 풀어보면 직관적으로 이해할 수 있다. 

> *Delegate 타입의 정의 방법* <br>
대상 메서드의 반환값과 인자를 분리하고, 식별자만 바꾼다 => 그 상태에서 delegate 예약어를 추가한다 
<br>

```cs
delegate int FuncDelegate(object arg);

Disk disk = new Disk();

FuncDelegate cleanFunc = new FunDelegate(disk.Clean);
```
<br>

또한 C# 2.0부터는 Delegate 타입을 좀 더 쉽게 사용할 수 있는데 new 없이 마치 일반 숫자형 타입처럼 대입할 수 있는 문법을 제공한다

```cs
FuncDelegate cleanFunc = disk.Clean;
```
<br> 

>  관례적으로 델리게이트 타입의 이름은 끝에 Delegate라는 접미사를 붙인다
<br>

그런데 이처럼 메서드를 가리키는 타입의 인스턴스인 cleanFunc이라는 변수로 어떤 역할을 할 수 있을까? 메서드를 가리키고 있으니 당연히 그 메서드를 호출하는 역할을 한다. 
```cs
disk.Clean(null);   //Clean 메서드를 직접 호출
cleanFunc(null);    //델리게이트 인스턴스를 통해 Clean 메서드를 호출
```
<br>

인스턴스가 메서드를 호출할 수 있다는 점을 제외하고는 델리게이트는 완전한 타입에 속한다. 델리게이트를 담는 배열도 만들 수 있고, 시그니처가 동일한 메서드라면 인스턴스/정적 유형에 상관없이 모두 가리킬 수 있다. 
<br>

델리게이트가 타입이라는 점은 중요하다. 이 때문에 변수가 사용되는 곳이라면 델리게이트 또한 함께 사용되는데, 이것은 다음과 같은 의미를 갖는다.

```
1. 메서드의 반환값으로 델리게이트를 사용할 수 있다.
2. 메서드의 인자로 델리게이트를 전달할 수 있다.
3. 클래스의 멤버로 델리게이트를 정의할 수 있다.
```
여기서 다시 한번 델리게이트가 메서드를 가리키는 것임을 떠올려보자. 따라서 다음과 같이 해석될 수 있다
```
1. 메서드의 반환값으로 메서드를 사용할 수 있다.
2. 메서드의 인자로 메서드를 전달할 수 있다.
3. 클래스의 멤버로 메서드를 정의할 수 있다. 
```
> 메서드가 프로그래밍 언어에서 이런 특성을 지닐 때 그것을 1급 홤수(First-class function)라 한다. 따라서 C#은 1급 함수가 지원되는 언어로, 이후 델리게이트의 특성을 좀 더 보강한 익명 함수, 람다 표현식이 사용된다. 

#### 델리게이트의 실체: 타입
그런데 왜 델리게이트가 타입일까? delegate라는 예약어가 사용된 것과 class 타입은 전혀 상관없는 관계로 보이는데 어떻게 타입과 동등한 위치에 있는 것일까? 이에 대한 해답은 delegate 예약어가 메서드를 가리킬 수 있는 내부 닷넷 타입에 대한 "간편 표기법"이라는 점에 있다. 그 내부 타입의 이름은 `MulticastDelegate`다.
<br>

> System.MulticastDelegate 타입은 System.Delegate 타입을 상속받고, 그것은 다시 System.Object를 상속 받는다.
<br>

> C#은 MulticastDelegate를 직접 상속해서 정의하는 구문을 허용하지 않는다.
<br>

MulticastDelegate를 알았으니 델리게이트를 좀 더 응용해 보자. 지금까지으 ㅣ예제에서 델리게이트 인스턴스는 하나의 메서드만 가리키고 있었는데 MulticastDelegate의 이름에서 볼 수 있는 것처럼 여러개의 메서드를 가리키는 것도 가능하다. 
<br>

특이하게 += 연산자를 이용해 메서드를 델리게이트 인스턴스에 추가한다. 여기서 직관적으로 +=과는 반대 개념인 -= 연산자도 지원하리라 예상할 수 있다.

#### 콜백메서드

콜백(callback) 메서드는 메서드를 사용하는 전형적인 패턴의 하나다. 이 개념을 완전하게 이해하려면 메서드 입장에서의 호출자(caller)와 피호출자(callee) 관계를 이해해야한다. 예를 들어, 사용자가 만든 Source 타입에서 Target 타입 내에 정의된 메서드를 호출한다고 하자. 그럼 호출자는 Source가 되고, 피호출자는 Target이 된다. 콜백이란 역으로 피호출자에서 호출자의 메서드를 호출하는 것을 의미하고 이때 역으로 호출된 "호출자 측의 메서드"를 콜백메서드라고 한다. 이 관계를 코드와 함께 알아보자. 

```cs
class Target
{
    public void Do(Source obj){     //1번
        Console.WriteLine(obj.GetResult());
    }
}

class Source{
    public int GetResult(){
        return 10;
    }

    public void Test(){
        Target target = new Target();
        target.Do(this);        //2번
    }
}
```
1번 호출에서는 Source 타입이 호출자이고 Target 타입이 피호출자가 된다. 하지만 피호출자가 정의한 Do 메서드 내부에서 다시 호출자의 타입에 정의된 메서드를 호출하고 있다. 바로 2번 호출을 콜백이라 하고 Source 타입의 GetResult 멤버가 콜백메서드가 된다. 
<br>
그런데 델리게이트가 콜백 호출 패턴에서 어떤 역할을 담당할 수 있을까? 콜백은 메서드를 호출하는 것이기 때문에 이 상황에서 실제 필요한 것은 타입이 아니라 하나의 메서드일 뿐이다. 따라서 타입 자체를 전달해서 실수를 유발할 여지를 남기기보다는 메서드에 대한 델리게이트만 전달해서 이 문제를 해결할 수 있다. 아래는 Target/Source 코드의 예제를 델리게이트를 사용해 다시 구현한 것이다. 
<br>

```cs
delegate int GetResultDelegate(); //int를 반환하고 매개변수가 없는 델리게이트 타입을 정의 

class Target
{
    public void Do(GetResultDelegate getResult)
    {
        Console.WriteLine(getResult());     //콜백 메서드 호출
    }
}

 class Source
{
    public int GetResult()
    {
        return 10;
    }

    public void Test()
    {
        Target target = new Target();
        target.Do(new GetResultDelegate(this.GetResult));
    }
}
```
> 피호출자가 호출하게 될 메서드가 꼭 호출자 내부에 정의된 메서드로 한정되는지 않는다. 다른 타입에 정의된 메서드를 피호출자에 전달해서 호출돼도 이런 식의 "역 호출"을 보통 콜백이라고 한다
<br>

위의 콜백 패턴을 잘 음미해 보자. Target 타입의 Do 메서드를 호출하면서 콜백 메서드를 전달했다. 이로 인해 Do 메서드는 내부의 동작에 콜백 매서드를 반영하게 된다. 이것은 마치 이미 정의된 코드로 치환하는 것과 같은 역할을 한다. 
<br>

코드를 치환한다는 의미를 적절히 살리는 예를 들어 보자. 아래를 일반적인 선택 정렬(select sort) 알고리즘을 구현한 프로그램이다.

```cs
using System;

namespace ConsoleApp
{
    class SortObject    //배열을 정렬할 수 있는 기능을 가진 타입 정의
    {
        int[] numbers;

        public SortObject(int[] numbers){   //배열을 생성자의 인자로 받아서 보관
            this.numbers = numbers;
        }

        public void Sort()  //전형적인 선택 정렬 알고리즘을 구현한 메서드
        {                   // numbers 배열의 요소를 크기순으로 정렬

            int temp;

            for(int i = 0; i < number.Length; i++){
                int lowPos = i;

                for(int j = i + 1; j < number.Length; j++){
                    if(numbers[j] < numbers[lowPos]){
                        lowPos = j;
                    }
                }

                temp = numbers[lowPos];
                numbers[lowPos] = numbers[i];
                numbers[i] = temp;
            }
        }

        public void Display()   //numbers 요소를 화면에 출력
        {
            for(int i = 0; i <numbers.length; i++){
                Console.Write(numbers[i] + ", ");
            }
        }
    }

    class Program{

        static void Main(string[] args)
        {
            int[] intArray = new int[] {5, 2, 3, 1, 0, 4};

            SortObject so = new SortObject(intArray);
            so.Sort();
            so.Display();
        }
    }
}
```
> 이 책은 알고리즘을 주제로 하는 책이 아니므로 선택 정렬에 대한 자세한 설명은 생략한다. 이 절의 내용은 선택 정렬을 알고 있느나와 무관하게 이해할 수 있으므로 델리게이트라는 주제에 집중하자.
<br>

SortObject 클래스는 Sort라는 단 하나의 메서드를 제공해서 int 형 배열을 크기순(오름차순:ascending)으로 정렬하고 있다. 그런데 여기서 배열을 내림차순(descending)으로 정렬하고 싶다면 어떻게 해야 할까? 이를 위해 고쳐야 할 코드는 단지 중첩 for 문 내의 비교 연산자 하나만 수정하면 된다.
```cs
public void Sort()
{
    //[생략]
    if(numbers[j] > numbers[lowPos])    //< 연산자를 >로 변경
    {
        lowPos=j;
    }
    //[생략]
}
```    
오름차순과 내림차순을 SortObject에서 함께 구현해야 한다면 각각을 구현하는 두 개의 Sort 메서드를 만들어야 할까? 단지 비교하는 코드 한 줄 때문에 대부분의 코드가 중복되는 메서드를 2개 만드는 것은 바람직하지 않다. 그렇다면 Sort 메서드에 bool ascending이라는 매개변수를 추가해 오름차순과 내림차순을 선택하게 하는 것도 좋다.
<br>   
<br>
나쁘지 않은 방법이지만 한번 더 생각해서 "비교하는 코드"를 외부에서 선택하도록 델리게이트로 만들어 버리는 것도 가능하다.

```cs
public delegate bool CompareDelegate(int arg1, int arg2);

public void Sort(CompareDelegate compareMethod){
    //[생략]
    if(compareMethod(numbers[j], numbers[lowPos])){
        lowPos = j;
    }
    //[생략]
}
```

 Sort 메서드의 코드는 간결해지고 오름차순, 내림차순을 외부에서 원하는 대로 정하는 것이 가능해졌다. 다음은 새롭게 정의된 Sort 코드를 사용하는 예제다.

```cs
static void Main(string[] args){
    int[] intArray = new int[] {5,2,3,1,0,4};

    SortObject so = new SortObject(intArray);
    so.Sort(AscendingCompare);  //오름차순 정렬을 할 수 있는 메서드 전달
    so.Display();

    public static bool AscendingCompare(int arg1, int arg2){
        return (arg1 < arg2);
    }

    public static bool DescendingCompare(int arg1, int arg2){
        return (arg1 > arg2);
    }
}
```
### 1.4 인터페이스
인터페이스(interface)는 간단하게 계약(contract)이라고 정의되며, 구현 없이 메서드 선언만 포함된 클래스 문법과 비슷한 면이 있다.
> *접근_제한자* **interace** *인터페이스_명*{ <br>
    // *[메서드 선언]* <br>
}

> 인터페이스에는 메서드 선언을 0개 이상 포함할 수 있다. 관례적으로 인터페이스 이름에는 ㅣ 접두사를 붙인다.

<br>
인터페이스를 "추상 메서드만 0개 이상 담고 있는 추상 클래스"라고 생각해도 무방하다. 
<br>
<br>
그렇다면 추상 클래스로 구현할 수 있는 것을 왜 굳이 interface라는 새로운 예약어를 만들어 표현하게 됬을까? 그에 대한 유일한 이유는 "클래스느 다중 상속이 불가능하다"라는 특징으로 설명할 수 있다. 추상 클래스는 말 그대로 클래스로 정의된 타입이라서 다중 상속을 할 수 없지만 인터페이스는 클래스가 아니기 때문에 다중 상속이 허용된다.
<br>
<br>
인터페이스의 메서드를자식 클래스에서 구현할 때는 반드시 public 접근 제한자를 명시해야 한다. 아니면 다음과 같이 인터페이스명을 직접 붙이는 경우 public 접근 제한자를 생략해도 된다. 한 가지 주의할 점은 public이 없다고 해서 private이 되는 건 아니라는 점이다. 
<br>
<br>
두 가지 메서드 구현 방식에는 호출하는 방법에 따른 차이점이 있다. 접근 제한자를 생략하고 인터페이스 명을 붙이는 후자의 경우에는 명시적으로 인터페이스의 멤버에 종속 시킨다고 표시하는 것과 같다. 따라서 불가능 할 경우에는 인터페이스로 형변환해야만 호출할 수 있다. 
<br>
<br>
인터페이스가 "메서드의 묶음"이고 , C# 프로퍼티가 내부적으로는 메서드로 구현되기 때문에 인터페이스에는 프로퍼티 역시 포함할 수 있다. 
<br>
<br>
인터페이스 자체는 이것으로 설명이 끝난다. '그런데 코드도 없이 단순하게 메서드 형식만 정의한 인터페이스가 도대체 어떤 효용성이 있는 것일까?라는 의문이 생길 수 있다.

#### 인터페이스와 다형성
인터페이스에 속한 메서드는 모두 가상 메서드에 속한다. C# 컴파일러가 인터페이스의 메서드를 가상 메서드로 간주하기 때문에 virtual 예약어를 지정하지 못하게 막는다. 아울러 인터페이스를 상속받은 자식 클ㄹ9ㅐ스에서도 해당 메서드에 override 예약어를 지정하지 못하게 막는다. 엄밀히 virtual/override 예약어를 막는다기 보다는 굳이 그럴 필요가 없으니 표시하지 못하게 한다는 표현이 어울린다.
<br>
인터페이스의 메서드는 가상 메서드이기 때문에 다형성의 특징이 그대로 적용된다.

> 인터페이스 자체는 new로 인스턴스화 할 수 없지만, 인터페이스 배열은 가능하다.

#### 인터페이스 자체로 의미 부여
인터페이스에 메서드가 포함돼 있지 않은 상태, 즉 비어 있는 인터페이스를 상속받는 것으로도 의미가 부여될 수 있다. 예를 들어, System.Object 클래스의 ToString을 재정의한 클래스만을 구분하고 싶다면 어떻게 해야할까? 인터페이스가 없다면 별도의 불린형 필드를 둬서 개발자가 명시해야 한다. 
<br>
<br>
한마디로 인터페이스는 여려분이 코드에서 자유롭게 정의할 수 있는 "계약"이다.

#### 인터페이스를 이용한 콜백 구현 
인터페이스에 포함된 메서드는 상속된 클래스에서 반드시 구현한다는 보장이 있다. 바로 이 점을 이용해 인터페이스를 이용한 콜백 구현이 가능하다.
<br>
<br>
낯설게 느껴지던 델리게이트를 사용하기보다는 오히려 "상속"이라는 이미 익숙한 개념으로 콜백을 구현하는 것으로 이해하기가 쉽다. 

> 여기서 잠깐 다른 언어인 자바와 비교해 보자, 콜백을 구현할 수 있는 중요 수단인 함수 포인터에 대해 C#은 델리게이트를 제공하지만 자바에는 이와 동등한 개념이 없다. 비록 자바가 델리게이트와 유사한 문법을 제공하지는 않지만 크게 문제가 안 되는 이유는 인터페이스가 있기 때문이다. 

<br>
그렇다면 콜백을 구현할 때 델리게이트와 인터페이스 중에 적당한 선택 기준이 있을까? 사실 거의 대부분의 콜백 패턴에 대해 인터페이스를 사용하는 방법이 더 선호된다. 왜냐하면 델리게이트는 각 메서드마다 정의해야 하는 불편함이 있지만 인터페이스는 하나의 타입에서 여러 개의 메서드 계약을 담을 수 있기 때문이다. 대신 델리게이트는 "여러 개의 메서드"를 담을 수 있어서 한 번의 호출을 통해 다중으로 등록된 콜백 메서드를 호출할 수 있다는 고유의 장점이 있다. 
<br>
<br>
따라서 다중 호출에 대한 필요성만 없다면 인터페이스를 이용해 콜백을 구현하는 것이 일반적이다. 실제로 닷넷 프레임워크에서 제공되는 타입 가운데 델리게이트보다는 종종 인터페이스가 사용된 예를 볼 수 있다. 가령 Array 타입의 멤버인 Sort 메서드가 한 예다. 
<br>
<br>

#### IEnumerable 인터페이스 
인터페이스를 알아본 김에 foreach 문법을 좀 더 깊이 있게 설명하기 위해 IEnumerable 인터페이스를 짚고 넘어가자. 
<br>
IEnumerable은 닷넷 프레임워크 내부에서 제공되며, 다음과 같이 정의돼 있다. 

```cs
// 닷넷 프레임워크에 정의되 있는 IEnumerable 인터페이스     
public interface IEnumerable{
    IEnumerator GetEnumerator();
}
```

인터페이스에 정의된 유일한 메서드인 GetEnumerator는 열거자(enumerator)라고 하는 객체를 반환하도록 약속돼 있다. 열거자 IEnumerator 인터페이스를 구현한 객체를 일컫는데, 다시 IEnumerator 인터페이스의 정의를 살펴보면 다음과 같다. 

 ```cs
 public interface IEnumerator 
 {
    object Current {get; } // 현재 요소를 반환하도록 약속된 get 프로퍼티
    bool MoveNext();       // 다음 순서의 요소로 넘어가도록 약속된 메서드 
    void Reset();          // 열거 순서를 처음으로 되돌릴 때 호출하면 되는 메서드
 }
 ```
IEnumerable 인터페이스를 구현한 전형적인 예는 System.Array다. 지금까지 만든 배열은 모두 System.Array를 상속받는다고 설명한 바 있으므로 배열은 다음과 같이 요소를 열람하는 것이 가능하다. 

```cs
int[] intArray = new int[] {1,2,3,4,5};

IEumerator enumerator = intArray.GetRenumerator();

while(enumerator.MoveNext())    // 더 이상 열거할 수 없을 때 false를 반환
{
    Console.Write(enumator.Current + ", ");  
}
```
배열 요소를 열람하는 데 뭔가 대단히 복잡하지 않은가? C#에서는 IEnumerable 인터페이스를 구현하고  있는 객체에 대해 좀 더 쉽게 열람할 수 있는 열거 문법을 제공한다. 제어 구문에서 설명한 foreach가 바로 그것이다. 
