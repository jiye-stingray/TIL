# 4-5 C#의 클래스 확장
클래스, 캡슐화, 상속, 다형성을 구현하는 것으로 C# 언어가 객체지향 언어라고 말할 수는 있지만 현실 세계에서 프로그래밍하려면 좀 더 다양한 요소가 필요하다. 

## 1. 타입 유형 확장 
지금까지 현실 세계의 다양한 객체를 class 구문을 이용해 프로그래밍 세계의 타입으로 구현해 봤다. 얼핏 생각해 보면 여기서 배운 class 만으로도 모든 구문을 표현할 수 있다고 자신할 수 있겠지만 프로그래밍하다 보면 좀 더 다양한 유형이 필요하다는 것을 깨닫게 된다.

### 1-1 중첩 클래스
중첩 클래스(nested class)는 클래스 내부에 또 다른 클래스를 정의하는 것이다. 그런데 그런 경우가 정말 필요할까? 예를 들어, 하드디스크를 생각해 보자. 하드 디스크는 내부에 플래터(platter)라고 하는 원형 금속판을 여러 개 포함하고 있으며, 헤드(head)가 그 금속판 위에 데이터를 읽고 쓰는 동작을 수행한다. 플래터와 헤드는 다른 구성 요소에 재사용되기보다는 하드 디스크 전용으로 내장되는 것이 일반적이다. 그런데도 각 요소를 클래스로 나누어 정의하면 플래터와 헤드가 다른 클래스에서 사용되는 것을 막을 수 없다. 자칫 개발자로 하여금 실수할 여지가 남아 있게 되는 것이다. 
<br>

class의 경우 접근 제한자를 생략하면 기본적으로 internal이 지정된다고 설명한 바 있다. 하지만 중첩 클래스의 경우 접근 제한자가 생략되면 다른 멤버와 마찬가지로 pricate이 지정되어 외부에서 인스턴스를 직접 생성하는 것이 불가능해진다. 중첩 클래스를 외부에서 사용하고 싶다면 명시적으로 public 접근 제한자를 지정해야 한다. 
<br>

### 1-2 추상 클래스
앞에서 설명한 메서드 오버라이드는 일반적으로 virtual 메서드를 정의한 부모 클래스에서 그에 대한 기본적인 기능을 구현하고, 자식 클래스에서는 override 예약어를 이용해 그 기능을 재정의 한다. 또한 부모 클래스와 자식 클래스 모두 new를 이용해 인스턴스를 생성하는 것이 가능하다. 그런데 때로는 부모 클래스의 인스턴스를 생성하지 못하게 하면서 특정 메서드에 대해 자식들이 반드시 재정의 하도록 강제하고 싶을 수 있다. 추상 클래스와 추상 메서드는 그와 같은 상황을 위해 존재한다. 
<br>

여기서 두 가지 새로운 개념이 나왔다. 우선 추상메서드는 abstract 예약어가 지정되고 구현 코드가 없는 메서드를 말한다. 추상 메서드는 일반 클래스에 존재할 수 없으며, 반드시 추상 클래스 안에서만 선언할 수 있다. abstract 예약어가 지정된 추상 메서드를 다른 말로 쉽게 정의하자면 "코드 없는 가상 메서드(virtual method)" 라고 이해하면 된다
<br>

> 추상 메서드에는 접근 제한자로 private을 지정할 수 없다. 추상 메서드는 반드시 자식 클래스에서 재정의 해야 한다는 점을 감안해 보면 이를 상식적으로 이해할 수 있다.
<br>

추상 클래스는 abstract 예약어가 지정돼 있다는 점을 제외하면 일반 클래스 정의와 완전히 동일하다. 이 예약어로 인해 일반 클래스와 차별화되는 점은 1) new를 사용해 인스턴스로 만들 수 없다는 것과 2) 추상 메서드를 가질 수 있다는 것뿐이다.
<br>

추상 메서드는 가상 메서드에 속하기 때문에 자식 클래스에서 override 예약어를 사용해 재정의한다. 당연히 가상 메서드이므로 다형성의 특징이 그대로 적용된다.
<br>

물론코드가 비어 있는 가상 메서드와 일반 클래스의 조합으로 정의해도 무방하다. 단지 가상 메서드는 자식 클래스에서 재정의 하지 않아도 컴파일할 때 오류가 발생하지 않지만 추상 클래스의 추상 메서드는 자식 클래스에서 반드시 재정의해야만 컴파일된다. 즉, 컴파일 단계에서부터 재정의를 강제하고 싶을 때 유용하게 사용할 수 있는 것이 바로 추상 클래스와 추상 메서드다. 

### 1-3 델리게이트
지금까지 배운 것처럼 타입은 "값"을 담을 수 있다. 그렇다면 그 "값"의 범위에 "메서드"도 포함될 수 있지 않을까? 
<br>

이렇게 메서드를 가리킬 수 있는 타입을 C#에서는 특별히 델리게이트(delegate)라는 구문으로 제공한다. 그런데 델리게이트 타입을 만드는 방법은 일반적인 class 구문이 아니고 delegate라는 예약어로 표현한다.

> __접근제한자 delegate 대상_메서드의_반환타입 식별자(.... 대상_메서드의 _매개변수_목록)__ <br>
대상이 될 메서드의 반환 타입 및 매개변수 목록과 일치하는 델리게이트 타입을 정의한다. 참고로 C/C++ 개발자에게는 델리게이트를 간단하게 함수 포인터라고 설명한다.
<br>

얼핏 보면 델리게이트를 정의하는 방법이 다소 어려울 수 있는데, 차근차근 풀어보면 직관적으로 이해할 수 있다. 

> *Delegate 타입의 정의 방법* <br>
대상 메서드의 반환값과 인자를 분리하고, 식별자만 바꾼다 => 그 상태에서 delegate 예약어를 추가한다 
<br>

```cs
delegate int FuncDelegate(object arg);

Disk disk = new Disk();

FuncDelegate cleanFunc = new FunDelegate(disk.Clean);
```
<br>

또한 C# 2.0부터는 Delegate 타입을 좀 더 쉽게 사용할 수 있는데 new 없이 마치 일반 숫자형 타입처럼 대입할 수 있는 문법을 제공한다

```cs
FuncDelegate cleanFunc = disk.Clean;
```
<br> 

>  관례적으로 델리게이트 타입의 이름은 끝에 Delegate라는 접미사를 붙인다
<br>

그런데 이처럼 메서드를 가리키는 타입의 인스턴스인 cleanFunc이라는 변수로 어떤 역할을 할 수 있을까? 메서드를 가리키고 있으니 당연히 그 메서드를 호출하는 역할을 한다. 
```cs
disk.Clean(null);   //Clean 메서드를 직접 호출
cleanFunc(null);    //델리게이트 인스턴스를 통해 Clean 메서드를 호출
```
<br>

인스턴스가 메서드를 호출할 수 있다는 점을 제외하고는 델리게이트는 완전한 타입에 속한다. 델리게이트를 담는 배열도 만들 수 있고, 시그니처가 동일한 메서드라면 인스턴스/정적 유형에 상관없이 모두 가리킬 수 있다. 
<br>

델리게이트가 타입이라는 점은 중요하다. 이 때문에 변수가 사용되는 곳이라면 델리게이트 또한 함께 사용되는데, 이것은 다음과 같은 의미를 갖는다.

```
1. 메서드의 반환값으로 델리게이트를 사용할 수 있다.
2. 메서드의 인자로 델리게이트를 전달할 수 있다.
3. 클래스의 멤버로 델리게이트를 정의할 수 있다.
```
여기서 다시 한번 델리게이트가 메서드를 가리키는 것임을 떠올려보자. 따라서 다음과 같이 해석될 수 있다
```
1. 메서드의 반환값으로 메서드를 사용할 수 있다.
2. 메서드의 인자로 메서드를 전달할 수 있다.
3. 클래스의 멤버로 메서드를 정의할 수 있다. 
```
> 메서드가 프로그래밍 언어에서 이런 특성을 지닐 때 그것을 1급 홤수(First-class function)라 한다. 따라서 C#은 1급 함수가 지원되는 언어로, 이후 델리게이트의 특성을 좀 더 보강한 익명 함수, 람다 표현식이 사용된다. 

#### 델리게이트의 실체: 타입
그런데 왜 델리게이트가 타입일까? delegate라는 예약어가 사용된 것과 class 타입은 전혀 상관없는 관계로 보이는데 어떻게 타입과 동등한 위치에 있는 것일까? 이에 대한 해답은 delegate 예약어가 메서드를 가리킬 수 있는 내부 닷넷 타입에 대한 "간편 표기법"이라는 점에 있다. 그 내부 타입의 이름은 `MulticastDelegate`다.
<br>

> System.MulticastDelegate 타입은 System.Delegate 타입을 상속받고, 그것은 다시 System.Object를 상속 받는다.
<br>

> C#은 MulticastDelegate를 직접 상속해서 정의하는 구문을 허용하지 않는다.
<br>

MulticastDelegate를 알았으니 델리게이트를 좀 더 응용해 보자. 지금까지으 ㅣ예제에서 델리게이트 인스턴스는 하나의 메서드만 가리키고 있었는데 MulticastDelegate의 이름에서 볼 수 있는 것처럼 여러개의 메서드를 가리키는 것도 가능하다. 
<br>

특이하게 += 연산자를 이용해 메서드를 델리게이트 인스턴스에 추가한다. 여기서 직관적으로 +=과는 반대 개념인 -= 연산자도 지원하리라 예상할 수 있다.

#### 콜백메서드

콜백(callback) 메서드는 메서드를 사용하는 전형적인 패턴의 하나다. 이 개념을 완전하게 이해하려면 메서드 입장에서의 호출자(caller)와 피호출자(callee) 관계를 이해해야한다. 예를 들어, 사용자가 만든 Source 타입에서 Target 타입 내에 정의된 메서드를 호출한다고 하자. 그럼 호출자는 Source가 되고, 피호출자는 Target이 된다. 콜백이란 역으로 피호출자에서 호출자의 메서드를 호출하는 것을 의미하고 이때 역으로 호출된 "호출자 측의 메서드"를 콜백메서드라고 한다. 이 관계를 코드와 함께 알아보자. 

```cs
class Target
{
    public void Do(Source obj){     //1번
        Console.WriteLine(obj.GetResult());
    }
}

class Source{
    public int GetResult(){
        return 10;
    }

    public void Test(){
        Target target = new Target();
        target.Do(this);        //2번
    }
}
```
1번 호출에서는 Source 타입이 호출자이고 Target 타입이 피호출자가 된다. 하지만 피호출자가 정의한 Do 메서드 내부에서 다시 호출자의 타입에 정의된 메서드를 호출하고 있다. 바로 2번 호출을 콜백이라 하고 Source 타입의 GetResult 멤버가 콜백메서드가 된다. 
<br>
그런데 델리게이트가 콜백 호출 패턴에서 어떤 역할을 담당할 수 있을까? 콜백은 메서드를 호출하는 것이기 때문에 이 상황에서 실제 필요한 것은 타입이 아니라 하나의 메서드일 뿐이다. 따라서 타입 자체를 전달해서 실수를 유발할 여지를 남기기보다는 메서드에 대한 델리게이트만 전달해서 이 문제를 해결할 수 있다. 아래는 Target/Source 코드의 예제를 델리게이트를 사용해 다시 구현한 것이다. 
<br>

```cs
delegate int GetResultDelegate(); //int를 반환하고 매개변수가 없는 델리게이트 타입을 정의 

class Target
{
    public void Do(GetResultDelegate getResult)
    {
        Console.WriteLine(getResult());     //콜백 메서드 호출
    }
}

 class Source
{
    public int GetResult()
    {
        return 10;
    }

    public void Test()
    {
        Target target = new Target();
        target.Do(new GetResultDelegate(this.GetResult));
    }
}
```
> 피호출자가 호출하게 될 메서드가 꼭 호출자 내부에 정의된 메서드로 한정되는지 않는다. 다른 타입에 정의된 메서드를 피호출자에 전달해서 호출돼도 이런 식의 "역 호출"을 보통 콜백이라고 한다
<br>

위의 콜백 패턴을 잘 음미해 보자. Target 타입의 Do 메서드를 호출하면서 콜백 메서드를 전달했다. 이로 인해 Do 메서드는 내부의 동작에 콜백 매서드를 반영하게 된다. 이것은 마치 이미 정의된 코드로 치환하는 것과 같은 역할을 한다. 
<br>

코드를 치환한다는 의미를 적절히 살리는 예를 들어 보자. 아래를 일반적인 선택 정렬(select sort) 알고리즘을 구현한 프로그램이다.

```cs
using System;

namespace ConsoleApp
{
    class SortObject    //배열을 정렬할 수 있는 기능을 가진 타입 정의
    {
        int[] numbers;

        public SortObject(int[] numbers){   //배열을 생성자의 인자로 받아서 보관
            this.numbers = numbers;
        }

        public void Sort()  //전형적인 선택 정렬 알고리즘을 구현한 메서드
        {                   // numbers 배열의 요소를 크기순으로 정렬

            int temp;

            for(int i = 0; i < number.Length; i++){
                int lowPos = i;

                for(int j = i + 1; j < number.Length; j++){
                    if(numbers[j] < numbers[lowPos]){
                        lowPos = j;
                    }
                }

                temp = numbers[lowPos];
                numbers[lowPos] = numbers[i];
                numbers[i] = temp;
            }
        }

        public void Display()   //numbers 요소를 화면에 출력
        {
            for(int i = 0; i <numbers.length; i++){
                Console.Write(numbers[i] + ", ");
            }
        }
    }

    class Program{

        static void Main(string[] args)
        {
            int[] intArray = new int[] {5, 2, 3, 1, 0, 4};

            SortObject so = new SortObject(intArray);
            so.Sort();
            so.Display();
        }
    }
}
```
> 이 책은 알고리즘을 주제로 하는 책이 아니므로 선택 정렬에 대한 자세한 설명은 생략한다. 이 절의 내용은 선택 정렬을 알고 있느나와 무관하게 이해할 수 있으므로 델리게이트라는 주제에 집중하자.
<br>

SortObject 클래스는 Sort라는 단 하나의 메서드를 제공해서 int 형 배열을 크기순(오름차순:ascending)으로 정렬하고 있다. 그런데 여기서 배열을 내림차순(descending)으로 정렬하고 싶다면 어떻게 해야 할까? 이를 위해 고쳐야 할 코드는 단지 중첩 for 문 내의 비교 연산자 하나만 수정하면 된다.
```cs
public void Sort()
{
    //[생략]
    if(numbers[j] > numbers[lowPos])    //< 연산자를 >로 변경
    {
        lowPos=j;
    }
    //[생략]
}
```    
오름차순과 내림차순을 SortObject에서 함께 구현해야 한다면 각각을 구현하는 두 개의 Sort 메서드를 만들어야 할까? 단지 비교하는 코드 한 줄 때문에 대부분의 코드가 중복되는 메서드를 2개 만드는 것은 바람직하지 않다. 그렇다면 Sort 메서드에 bool ascending이라는 매개변수를 추가해 오름차순과 내림차순을 선택하게 하는 것도 좋다.
<br>   
<br>
나쁘지 않은 방법이지만 한번 더 생각해서 "비교하는 코드"를 외부에서 선택하도록 델리게이트로 만들어 버리는 것도 가능하다.

```cs
public delegate bool CompareDelegate(int arg1, int arg2);

public void Sort(CompareDelegate compareMethod){
    //[생략]
    if(compareMethod(numbers[j], numbers[lowPos])){
        lowPos = j;
    }
    //[생략]
}
```

 Sort 메서드의 코드는 간결해지고 오름차순, 내림차순을 외부에서 원하는 대로 정하는 것이 가능해졌다. 다음은 새롭게 정의된 Sort 코드를 사용하는 예제다.

```cs
static void Main(string[] args){
    int[] intArray = new int[] {5,2,3,1,0,4};

    SortObject so = new SortObject(intArray);
    so.Sort(AscendingCompare);  //오름차순 정렬을 할 수 있는 메서드 전달
    so.Display();

    public static bool AscendingCompare(int arg1, int arg2){
        return (arg1 < arg2);
    }

    public static bool DescendingCompare(int arg1, int arg2){
        return (arg1 > arg2);
    }
}
```
### 1.4 인터페이스
인터페이스(interface)는 간단하게 계약(contract)이라고 정의되며, 구현 없이 메서드 선언만 포함된 클래스 문법과 비슷한 면이 있다.
> *접근_제한자* **interace** *인터페이스_명*{ <br>
    // *[메서드 선언]* <br>
}

> 인터페이스에는 메서드 선언을 0개 이상 포함할 수 있다. 관례적으로 인터페이스 이름에는 ㅣ 접두사를 붙인다.

<br>
인터페이스를 "추상 메서드만 0개 이상 담고 있는 추상 클래스"라고 생각해도 무방하다. 
<br>
<br>
그렇다면 추상 클래스로 구현할 수 있는 것을 왜 굳이 interface라는 새로운 예약어를 만들어 표현하게 됬을까? 그에 대한 유일한 이유는 "클래스느 다중 상속이 불가능하다"라는 특징으로 설명할 수 있다. 추상 클래스는 말 그대로 클래스로 정의된 타입이라서 다중 상속을 할 수 없지만 인터페이스는 클래스가 아니기 때문에 다중 상속이 허용된다.
<br>
<br>
인터페이스의 메서드를자식 클래스에서 구현할 때는 반드시 public 접근 제한자를 명시해야 한다. 아니면 다음과 같이 인터페이스명을 직접 붙이는 경우 public 접근 제한자를 생략해도 된다. 한 가지 주의할 점은 public이 없다고 해서 private이 되는 건 아니라는 점이다. 
<br>
<br>
두 가지 메서드 구현 방식에는 호출하는 방법에 따른 차이점이 있다. 접근 제한자를 생략하고 인터페이스 명을 붙이는 후자의 경우에는 명시적으로 인터페이스의 멤버에 종속 시킨다고 표시하는 것과 같다. 따라서 불가능 할 경우에는 인터페이스로 형변환해야만 호출할 수 있다. 
<br>
<br>
인터페이스가 "메서드의 묶음"이고 , C# 프로퍼티가 내부적으로는 메서드로 구현되기 때문에 인터페이스에는 프로퍼티 역시 포함할 수 있다. 
<br>
<br>
인터페이스 자체는 이것으로 설명이 끝난다. '그런데 코드도 없이 단순하게 메서드 형식만 정의한 인터페이스가 도대체 어떤 효용성이 있는 것일까?라는 의문이 생길 수 있다.

#### 인터페이스와 다형성







