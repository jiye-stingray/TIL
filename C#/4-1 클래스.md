# 클래스

특정 사물의 특징 중에는 자료형으로 표현할 수 있는 여러 가지 값이 존재하고, 객체지향에서는 이를 속성(attriute)이라고 한다. 하지만 사물의 특징에는 속성만 있는 것은 아니다. 사물끼리 상호작용할때 행위(behavior)를 한다.
<br>

현실 세계의 모든 것을 정의할 수 있는게 **객체지향**의 핵심 개념이다

> * 클래스의 구성
    - 인스턴스(instance)
    - 타입(type)
<br>

 왜 기본 타입 외에 별도로 객체 지향 개념을 받아들여 새롭게 타입을 정의해야만 할까? 

그것은 *기본 자료형* 에 속하는 타입만으로는 현실 세계를 모델링하기에 역부족이기 때문이다. 객체지향 프로그래밍 언어는 기본 타입 외에 개발자가 원하는 모든 객체의 타입을 새롭게 정의해서 사용할 수 있게 한다.

## 1. 필드
클래스에 정의 된 속성을 **필드(field)** 라고 한다.
객체에 포함된 필드를 프로그램에서 사용할 때는 다음과 같은 구문을 따른다.
<br>

* 필드에 값을 대입<br>
*객체.필드명 = 필드의_타입과_일치하는_표현식;*
<br>
* 필드로 부터 값을 가져옴<br>
*필드의_타입과_일치하는_변수 = 객체.필드명;*


## 2.메서드
타입에는 속성과 행위를 정의한다. 속성은 C# 코드에서 필드로 표현되고, 행위는 메서드(method)로 표현된다.  메서드라는 말은 보통 객체지향 프로그래밍 언어에서 사용된다. (C 언어에서의 함수(function))

메서드를 호출하는 측에서 전달하는 값은 메서드의 인자(argument)라고 한다. 메서드 내에서는 전달된 인자 값을 매개변수에 대응 시켜 사용할 수 있다.

> 일반적으로는 인자와 매개변수의 의미를 정확히 구분지어 부르지 않을 때도 많다.

### 2-1. 중복 제거
전통적으로 함수는 코드를 재사용하기 쉽게 만들어 주는 역활을 해왔다. 
중복된 코드는 향후 유지보수를 어렵게 만든다는 심각한 단점이 있다. 메서드를 사용하면 이런 문제를 개선 할 수 있다. 관리해야할 코드가 한 곳에 모이고, 이를 재사용할 수 있기 때문에 좀 더 간결하게 프로그램을 만들 수 있다. 한 번만 사용하면 되는 코드를 메서드로 분리해야 할지에 대해서는 `선택의 문제` 이지만 해당 코드가 두 번 이상 반복된다면 무조건 메서드로 분리하자.

### 2-2. 코드 추상화
메서드는 특정 목적을 수행하는 일련의 코드를 모아서 입력 인자와 출력인자를 정의해 추상화 할 수 있다. 메서드 역시 간단하게 객체에 속한 함수라고 생각하면 되고, 이 떄문에 멤버 메서드(member method)라고 불린다, 결국 필드와 메서드는 모두 해당 타입의 멤버에 속한다. 클래스의 핵심인 필드와 메서드를 배웠으니, 이제 class를 새롭게 다음과 같은 시각으로 바라볼 수 있다.

> 타입(class) = 속성(field) + 행위(method)

클래스는 데이터를 속성으로, 코드를 메서드로 추상화한 개념으로 객체지향 프로그래밍 언어에서 현실 세계와 프로그램 세계를 잇는 다리 역할을 한다.

## 3. 생성자
C# 클래스에는 특별한 용도의 메서드가 있다. 그 중 하나는 생성자(constructor)이다. 클래스에서 생성자 메서드를 추가하면 객체가 `생성` 되는 시점에 해당 메서드가 자동으로 호출 된다. 이런 점에서 생성자는 다른 여타 메서드와 구별되는 특징이 있다. 

```cs
class 클래스_명
{
    접근_제한자 클래스_명(타입 매개변수명, ......)
    {

    }

}
```
사실 모든 클래스는 생성자를 가지고 있다. 생성자를 명시적으로 정의하지 않았다면 일부러 다음과 같은 빈 생성자를 클래스에 집어넣고 컴파일한다. 
<br>
따라서 new를 실행하면 언제나 해당 객체의 생성자가 함께 실행된다. 아울러 생성자 역시 다른 일반 메서드처럼 매개변수를 가질 수 도 있다. 일반적으로 매개변수를 갖는 생성자를 통해 외부로부터 객체를 초기화 하는 값을 입력 받는다. 
<br>
한 가지 주의할 점은 개발자가 명시적으로 생성자를 정의한 경우 컴파일러는 기본 생성자를 추가하지 않는다는 것이다. 
<br>
생성자를 여러개 정의하는 것도 가능하다

## 4.종료자
클래스에 생성자가 있다면 해당 객체가 제거되는 시점에 실행될 종료자(finalizer)(또는 파괴자)도 있을 거라고 예측할 수 있다.

```cs
class 클래스_명
{
    ~클래스_명()
    {
        //......[자원 해제를 위한 코드]......
    }
}
```
> 종료자는 이름이 ~(틸드: tilde)를 접두사로 쓰는 클래스명과 동일하며 어떤 인자나 반환값도 갖지 않는다. 종료자가 실행되는 시점은 예측할 수 없다.
<br>

생성자의 경우 사용자가 명시적으로 new를 통해 객체를 할당하는 시점에 자동으로 호출된다고 했는데, 그렇다면 종료자는 언제 호출되는 걸까? C#에는 delete 같은 예약어가 없으므로 사용자가 객체를 의도적으로 제거하는 기능이 없다. 상식적으로 생각해 봐도 데이터를 메모리에 할당만 하고 제거를 하지 않으면 언젠가는 주소 공간이 바닥나므로 프로그램이 제대로 동작하지 않게 된다.
<br>

CLR 에서는 이런 문제를 내부적으로 가비지 수집기(Garbage Collector, 이하 GC)라는 개념을 도입해서 해결하고 있다. C# 프로그램에서 모든 참조형 변수를 생성할 때는 GC가 관여하게 되고, GC는 요청된 변수의 타입이 요구하는 메모리를 `관리 힙` 이라는 곳에 할당한다. 또한 프로그램이 실행되고 있는 중에 GC는 스스로 적절하다고 판단되는 시점이 오면 관리 힙을 청소하는 작업을 하는데, 이때 어떤 객체가 더는 사용되고 있지 않다면 객체의 데이터를 해제해 버린다. 따라서 C#의 참조형 변수가 가리키는 객체는 GC기가 호출되야 종료자가 호출된다. 한 가지 확실한 사실은 GC가 불확실한 시점에 메모리 정리를 한다는 것이다.
<br>

종료자를 사용할 때는 정의하기에 앞서 신중하게 고민하고 판단해야 한다. 왜냐하면 GC 입장에서는 일반 참조 객체와는 달리 종료자가 정의된 클래스의 객체를 관리하려면 더 복잡한 과정을 거쳐야 하므로 성능 면에서 부하를 줄 수 있기 때문이다. 
<br>

이 경우 기준은 하나다. 닷넷이 관리하지 않는 시스템 자원을 얻은 경우에만 종료자를 정의하라. 이런 경우는 아직 한번도 없었으므로 아직까지는 종료자를 정의해야 할 이유가 아무것도 없다. 나중에 네이티브(Native) 프로그램과의 협업을 다룰 때 이부분에 대해 다시 이야기 할 것이다. 그때까지는 종료자가 단지 메서드의 특별한 유형이라는 점만 기억해 두고 넘어가자.

## 5. 정적 멤버, 인스턴스 멤버
어떤 타입을 실체화한 객체를 인스턴스라고 한다. 인스턴스를 달리 표현하면 new 연산자를 거쳐서 메모리에 할당된 객체라고 할 수 있다. 바로 그 객체와 관련된 멤버를 인스턴스 멤버(instance member)라고 하며, 지금까지 설명한 필드, 메서드, 생성자는 모두 여기 속한다. 
<br>

하지만 때로는 인스턴스와 관계없는 행동을 정의해야 할 때가 있다. 즉, 개별 인스턴스 수준이 아닌 해당 인스턴스의 타입 전체에 걸쳐 전역적으로 적용되는 필드, 메서드, 생성자가 필요할 수 있는데, 이러한 멤버를 인스턴스 멤버와 구분해 정적 멤버(static member)라고 한다.
<br>

### 5-1. 정적 필드
정적 필드를 사용하는 전형적인 패턴 가운데 대표적으로 한가지를 꼽으라면 특정 클래스의 인스턴스를 의도적으로 단 한 개만 만들고 싶은 경우다. 이 경우 클래스 밖에서 해당 클래스의 인스턴스를 만들지 못하게끔 생성자를 private 접근 제한자로 명시하고 단 하나의 인스턴스만 클래스 내부에서 미리 생성해 두는 것으로 원하는 바를 이룰 수 있다. 
<br>

이렇게 인스턴스가 단 하나만 존재하는 타입을 특별하게 싱글턴(singleton) 클래스라고 하며, 이따금 단일 시스템 자원을 책임지는 타입이 필요할 때 싱글턴 클래스를 만들어 다른 클래스 기능을 노출하는 용도로 사용한다. 

### 5-2. 정적 메서드
정적 메서드(static method)는 일반 메서드에 static 예약어를 붙여서 정의한다. 정적 메서드 역시 new로 객체를 생성하는 것과 무관하게 상용할 수 있으므로 `클래스이름.정적메서드` 형태로 호출할 수 있다. 
<br>

정적 메서드 안에서는 인스턴스 멤버에 접근 할 수 없다는 특징이 있다. 이는 정적 메서드가 new로 할당된 객체가 없는 상태에서도 호출되는 메서드라는 점을 생각하면 쉽게 이해할 수 있다.
<br>
Main 메서드도 정적 메서드에 속하지만 C#에서 다소 특별한 대우를 받기 때문에 좀 더 부가적인 설명이 필요하다.

##### Main 메서드
프로그램은 CPU에 의해 순차적으로 실행되는 특징을 지닌다. C#으로 만든 프로그램도 역시 순서대로 명령어가 실행되는데, 그렇다면 가장 처음 실행되는 명령어가 뭘까? 다른 말로 진입점(entry point)이라고도 하는데 C#은 다음과 같은 약속을 따르는 메서드를 최초로 실행될 메서드라고 규정한다.


1. 메서드 이름은 반드시 Main이고,<br>
2. 정적 메서드여야하고,
3. Main 매서드가 정의된 클래스의 이름은 제한이 없다. 하지만 2개 이상의 클래스에서 Main 메서드를 정의하고 있다면 C# 컴파일러에게 클래스를 지정해야 함
4. Main 메서드의 반환값은 void 또는 int 만 허용됨
5. Main 메서드의 매개변수는 없거나 string 배열만 허용됨

이 규칙을 만족하는 메서드를 정의하면 C# 컴파일러는 자동으로 그 메서드를 시작점으로 선택해 EXE 파일을 생성한다.

### 5-3.정적 생성자
정적 생성자(static constructor)는 기본 생성자으 static 예약어를 붙인 경우로 클래스에 단 한개만 존재 할 수 있고, 주로 정적 멤버를 초기화 하는 기능을 하기 떄문에 형식 이니셜라이져(type initializer)라고도 한다.

> 정적 필드에 초기화 코드도 포함돼 있고, 동시에 정적 생성자도 정의해 뒀다면 C# 컴파일러는 사용자가 정의한 정적 생성자의 코드와 초기화 코드를 자동으로 병합해서 정의한다. 이 규칙은 인스턴스 필드와 기본 생성자 간에도 동일하게 적용된다. 

정적 생성자는 클래스의 어떤 멤버든 최초로 접근하는 시점에 단 한 번만 실행된다는 점을 기억해 두자. 정적 멤버를 처음 호출할 경우이거나 인스턴스 생성자를 통해 객체가 만들어지는 시점이 되면 그 어떤 코드보다도 우선적으로 실행된다. 

## 6. 네임스페이스
네임스페이스(namespace)는 말 그대로 "이름 공간"이라고 번역되는데, 태생 자체는 이름이 중복되어 정의된 것을 구분하려는 의도에서 나온 것이지만, 더 일반적으로는 수많은 클래스를 분류하는 방법으로 사용되고 있다. 
<br>

인간의 언어를 보면 몇몇 단어의 경우 이름은 같지만 의미가 다른 것을 종종 볼 수 있다. 예를 들어, 먹는 배(Pear)와 타는 배(Ship)는 서로 다른 것을 지칭한다. 다행히 사람의 뇌는 서로 오가는 대화의 문맥을 통해 "배"라고 해도 어떤 것을 지칭하는지 판단할 수 있지만 컴파일러는 그런 상황에서 적절한 의미선택을 할 수 없으므로 이름 충돌(naming conflict)이라는 오류를 발생 시킨다.
<br>

바로 이런 문제를 해결하기 위해 개발자가 "문맥"에 해당하는 힌트를 컴파일러에게 줘야 하는데, 이것이 코드의 이름 공간(namespace)이 된다. 
<br>

namespace로 구분된 블록 내에서는 동일한 이름공간이 적용된다. 만약 네임스페이스가 다른 곳에서 클래스를 생성해야한다면 해당 클래스가 속한 네임스페이스까지 모두 명시해야 한다. 즉, `네임스페이스.클래스`와 같은 형식으로 간단하게 지정할 수 있다. 물론 namespace 이름까지도 같다면 다시 이름 충돌이 발생한다. 그래서 일부 언어에서는 namespace로 사용되는 이름을 해당 업체가 소유한 웹 사이트의 도메인 이름으로 사용할 것을 권장해서 충돌 확률을 더욱 낮추기도 한다. 그리고 namespace는 그 안에 또 다른 namespace를 중첩하는 것도 가능하기 때문에 이름 충돌로 인한 문제는 설령 발생하더라도 대부분 손쉽게 해결할 수 있다. 
<br>

그런데 현실적으로 보면 네임스페이스가 이름 충돌 때문에 사용되는 경우는 많지 않다. 대신 클래스의 소속을 구분하는 데 사용되는 것이 더 일반적이다. 
<br>

C#은 using 이라는 예약어를 추가했고, 이를 이용해 네임스페이스를 미리 선언해 두면 객체를 생성할 때 이를 생략해도 C# 컴파일러가 알아서 객체가 속한 네임스페이스를 찾아내어 오류 없이 컴파일 한다. 
<br>

현업에서 개발하다 보면 종종 FQDN(Fully Qualified Domain Name)이라는 단어를 듣게 된다. 이는 업계마다 여러 가지 다른 의미로 사용되는데, C# 프로그래밍에서는 일반적으로 네임스페이스가 생략된 클래스명과 구분해서 클래스명에 네임스페이스까지 함께 지정하는 경우 특별히 FQDN이라고 한다. 
예를 들어 Console 클래스의 FQDN은 System.Console 이다.

