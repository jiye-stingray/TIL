# 클래스

특정 사물의 특징 중에는 자료형으로 표현할 수 있는 여러 가지 값이 존재하고, 객체지향에서는 이를 속성(attriute)이라고 한다. 하지만 사물의 특징에는 속성만 있는 것은 아니다. 사물끼리 상호작용할때 행위(behavior)를 한다.
<br>

현실 세계의 모든 것을 정의할 수 있는게 **객체지향**의 핵심 개념이다

> * 클래스의 구성
    - 인스턴스(instance)
    - 타입(type)
<br>

 왜 기본 타입 외에 별도로 객체 지향 개념을 받아들여 새롭게 타입을 정의해야만 할까? 

그것은 *기본 자료형* 에 속하는 타입만으로는 현실 세계를 모델링하기에 역부족이기 때문이다. 객체지향 프로그래밍 언어는 기본 타입 외에 개발자가 원하는 모든 객체의 타입을 새롭게 정의해서 사용할 수 있게 한다.

## 1. 필드
클래스에 정의 된 속성을 **필드(field)** 라고 한다.
객체에 포함된 필드를 프로그램에서 사용할 때는 다음과 같은 구문을 따른다.
<br>

* 필드에 값을 대입<br>
*객체.필드명 = 필드의_타입과_일치하는_표현식;*
<br>
* 필드로 부터 값을 가져옴<br>
*필드의_타입과_일치하는_변수 = 객체.필드명;*


## 2.메서드
타입에는 속성과 행위를 정의한다. 속성은 C# 코드에서 필드로 표현되고, 행위는 메서드(method)로 표현된다.  메서드라는 말은 보통 객체지향 프로그래밍 언어에서 사용된다. (C 언어에서의 함수(function))

메서드를 호출하는 측에서 전달하는 값은 메서드의 인자(argument)라고 한다. 메서드 내에서는 전달된 인자 값을 매개변수에 대응 시켜 사용할 수 있다.

> 일반적으로는 인자와 매개변수의 의미를 정확히 구분지어 부르지 않을 때도 많다.

### 2-1. 중복 제거
전통적으로 함수는 코드를 재사용하기 쉽게 만들어 주는 역활을 해왔다. 
중복된 코드는 향후 유지보수를 어렵게 만든다는 심각한 단점이 있다. 메서드를 사용하면 이런 문제를 개선 할 수 있다. 관리해야할 코드가 한 곳에 모이고, 이를 재사용할 수 있기 때문에 좀 더 간결하게 프로그램을 만들 수 있다. 한 번만 사용하면 되는 코드를 메서드로 분리해야 할지에 대해서는 `선택의 문제` 이지만 해당 코드가 두 번 이상 반복된다면 무조건 메서드로 분리하자.

### 2-2. 코드 추상화
메서드는 특정 목적을 수행하는 일련의 코드를 모아서 입력 인자와 출력인자를 정의해 추상화 할 수 있다. 메서드 역시 간단하게 객체에 속한 함수라고 생각하면 되고, 이 떄문에 멤버 메서드(member method)라고 불린다, 결국 필드와 메서드는 모두 해당 타입의 멤버에 속한다. 클래스의 핵심인 필드와 메서드를 배웠으니, 이제 class를 새롭게 다음과 같은 시각으로 바라볼 수 있다.

> 타입(class) = 속성(field) + 행위(method)

클래스는 데이터를 속성으로, 코드를 메서드로 추상화한 개념으로 객체지향 프로그래밍 언어에서 현실 세계와 프로그램 세계를 잇는 다리 역할을 한다.

## 3. 생성자
C# 클래스에는 특별한 용도의 메서드가 있다. 그 중 하나는 생성자(constructor)이다. 클래스에서 생성자 메서드를 추가하면 객체가 `생성` 되는 시점에 해당 메서드가 자동으로 호출 된다. 이런 점에서 생성자는 다른 여타 메서드와 구별되는 특징이 있다. 

```cs
class 클래스_명
{
    접근_제한자 클래스_명(타입 매개변수명, ......)
    {

    }

}
```
사실 모든 클래스는 생성자를 가지고 있다. 생성자를 명시적으로 정의하지 않았다면 일부러 다음과 같은 빈 생성자를 클래스에 집어넣고 컴파일한다. 
<br>
따라서 new를 실행하면 언제나 해당 객체의 생성자가 함께 실행된다. 아울러 생성자 역시 다른 일반 메서드처럼 매개변수를 가질 수 도 있다. 일반적으로 매개변수를 갖는 생성자를 통해 외부로부터 객체를 초기화 하는 값을 입력 받는다. 
<br>
한 가지 주의할 점은 개발자가 명시적으로 생성자를 정의한 경우 컴파일러는 기본 생성자를 추가하지 않는다는 것이다. 
<br>
생성자를 여러개 정의하는 것도 가능하다

## 4.종료자
클래스에 생성자가 있다면 해당 객체가 제거되는 시점에 실행될 종료자(finalizer)(또는 파괴자)도 있을 거라고 예측할 수 있다.

```cs
class 클래스_명
{
    ~클래스_명()
    {
        //......[자원 해제를 위한 코드]......
    }
}
```
> 종료자는 이름이 ~(틸드: tilde)를 접두사로 쓰는 클래스명과 동일하며 어떤 인자나 반환값도 갖지 않는다. 종료자가 실행되는 시점은 예측할 수 없다.
<br>

생성자의 경우 사용자가 명시적으로 new를 통해 객체를 할당하는 시점에 자동으로 호출된다고 했는데, 그렇다면 종료자는 언제 호출되는 걸까? C#에는 delete 같은 예약어가 없으므로 사용자가 객체를 의도적으로 제거하는 기능이 없다. 상식적으로 생각해 봐도 데이터를 메모리에 할당만 하고 제거를 하지 않으면 언젠가는 주소 공간이 바닥나므로 프로그램이 제대로 동작하지 않게 된다.
<br>

CLR 에서는 이런 문제를 내부적으로 가비지 수집기(Garbage Collector, 이하 GC)라는 개념을 도입해서 해결하고 있다. C# 프로그램에서 모든 참조형 변수를 생성할 때는 GC가 관여하게 되고, GC는 요청된 변수의 타입이 요구하는 메모리를 `관리 힙` 이라는 곳에 할당한다. 또한 프로그램이 실행되고 있는 중에 GC는 스스로 적절하다고 판단되는 시점이 오면 관리 힙을 청소하는 작업을 하는데, 이때 어떤 객체가 더는 사용되고 있지 않다면 객체의 데이터를 해제해 버린다. 따라서 C#의 참조형 변수가 가리키는 객체는 GC기가 호출되야 종료자가 호출된다. 한 가지 확실한 사실은 GC가 불확실한 시점에 메모리 정리를 한다는 것이다.
<br>

종료자를 사용할 때는 정의하기에 앞서 신중하게 고민하고 판단해야 한다. 왜냐하면 GC 입장에서는 일반 참조 객체와는 달리 종료자가 정의된 클래스의 객체를 관리하려면 더 복잡한 과정을 거쳐야 하므로 성능 면에서 부하를 줄 수 있기 때문이다. 
<br>

이 경우 기준은 하나다. 닷넷이 관리하지 않는 시스템 자원을 얻은 경우에만 종료자를 정의하라. 이런 경우는 아직 한번도 없었으므로 아직까지는 종료자를 정의해야 할 이유가 아무것도 없다. 나중에 네이티브(Native) 프로그램과의 협업을 다룰 때 이부분에 대해 다시 이야기 할 것이다. 그때까지는 종료자가 단지 메서드의 특별한 유형이라는 점만 기억해 두고 넘어가자.

## 5. 정적 멤버, 인스턴스 멤버
어떤 타입을 실체화한 객체를 인스턴스라고 한다. 인스턴스를 달리 표현하면 new 연산자를 거쳐서 메모리에 할당된 객체라고 할 수 있다. 바로 그 객체와 관련된 멤버를 인스턴스 멤버(instance member)라고 하며, 지금까지 설명한 필드, 메서드, 생성자는 모두 여기 속한다. 
<br>

하지만 때로는 인스턴스와 관계없는 행동을 정의해야 할 때가 있다. 즉, 개별 인스턴스 수준이 아닌 해당 인스턴스의 타입 전체에 걸쳐 전역적으로 적용되는 필드, 메서드, 생성자가 필요할 수 있는데, 이러한 멤버를 인스턴스 멤버와 구분해 정적 멤버(static member)라고 한다.
<br>

### 5-1. 정적 필드


