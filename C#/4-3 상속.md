# 상속

현실 세계는 객체마다 어떤 공통적인 특징이 있고, 그 특징을 상속(inheritance)받아 다른 세부적인 항목을 정의하는데, 일상적인 많은 객체가 이러한 "꼐층적"인 관계를 따르고 있다. 
<br>

상속을 이용하면 공통적인 특징을 정의하는 부모 클래스(parent class)를 두고 자식 클래스(child class)에서 부모의 기능을 물려받는 식으로 처리할 수 있다. 
> 부모 클래스는 다른 말로 기반(base) 클래스 또는 슈퍼(super)클래스라고도 한다. 그리고 자식 클래스는 다른 말로 파생(derived) 클래스 또는 서브(sub)클래스라고도 한다. 아울러 부모 또한 부모를 가질 수 있기 때문에 조상(ancestor) 클래스라는 표현이 있으며, 반대로 자손 클래스라는 표현도 있다.
<br>

C# 클래스에서는 콜론(':')을 이용해 부모 클래스의 기능을 물려받을 수 있고 실제로 상속받은 클래스는 부모의 속성과 행위를 접근 제한자 규칙에 따라 외부에 제공한다. 
<br>

흔치 않지만 프로그래밍하다 보면 상속을 의도적으로 막고 싶을 때도 있다. 일례로 자주 쓰는 string 타입은 상속을 받지 못하도록 제한되 있는데, 이는 sealed 예약어가 적용돼 있기 때문이다. 
```cs
sealed class Pen{

}
public class ElectricPen : Pen // 컴파일 오류 발생
{

}
```
마지막으로, C#의 상속에 대해 언급해야 할 것이 있다면 단일 상속(single inheritance)만 지원한다. C#은 `계층 상속`은 가능하지만 동시에 둘 이상의 부모 클래스로부터 다중 상속을 받는 것은 허용되지 않는다. 
<br>

엄밀히 상속 자체의 개념은 부모의 기능을 물려받는 것으로 매우 간단하게 설명되지만, 그로 인해 파생되는 여러 가지 개념이 복잡하게 얽혀 있다.

## 1. 형변환
**암시적 형변환** 
특수화 타입의 변수에서 일반화된 타입의 변수로 값이 대입되는 대입되는 경우  
```cs
short a = 100; 
int b = a; //암시적 형변환 가능
```
**명시적 형변환** 
일반화 타입의 변수에서 특수화된 타입의 변수로 값이 대입되는 경우
```cs
int c = 100;
short d = (short)c; //명시적 형변환
```
이 규칙은 class로 정의된 타입의 부모/자식 관계에도 동일하게 적용된다.
<br>

특수화 타입 인스턴스를 일반화 타입의 변수로 대입하는 경우에는 암시적 형변환이 가능하지만 반대로 부모 클래스(일반화 타입)의 인스턴스를 자식 클래스(특수화 타입)의 변수로 대입하는 것은 불가능하다. 물론 강제로 캐스팅 연산자를 사용해 명시적 형변환을 하는 것은 가능하지만 실행하면 오류가 발생한다. 
<br>

부모에서 할당한 메모리에는 자식을 위한 멤버의 특성을 반영하고 있지 않다. 
<br>

그렇다면 컴파일 단계에서 명시적 형변환을 불가능하게 만들었으면 좋지 않았을까? 그렇게 할 수 없는 이유는 개발자가 의도적으로 원하는 경우도 있기 때문이다. 예를 들어, 자식 인스턴스를 가리키는 부모 클래스의 변수가 다시 자식 타입의 변수로 대입될 수 있다. 
<br>
현실적으로 볼 때 클래스 간의 명시적 형변환보다는 암시적 형변환이 좀 더 자주 사용된다. 또한 각 자식 클래스의 인스턴스를 부모 객체의 배열에 담을 수 있는 것도 암시적 형변환 덕분이다. 

### 1-1. as, is 연산자 
클래스의 형변환에서 빠질 수 없는 것이 바로 as 연산자 이다. 캐스팅 연산자를 사용해 명시적 형변환을 하는 경우 컴파일 단계가 아닌 프로그램을 실행할 때 오류가 발생한다는 것을 알았다. 닷넨 프로그램에서 오류를 발생시키는 것은 내부적으로 제법 부하가 큰 동작에 속한다. 따라서 오류를 발생시키지 않고도 형변환이 가능한지 확인할 수 있는 방법이 필요했고 이를 위해 as 연산자가 추가됐다. 
<br>

as는 형변환이 가능하면 지정된 ㅌ타입의 인스턴스 값을 반환하고, 가능하지 않으면 null 값을 반환하기 때문에 null 변환 여부를 통해 형변환이 성공했는지 판단할 수 있다. 한 가지 기억해야할 점은 as 연산자는 참조형 변수에 대해서만 적용할 수 있고 참조형 타입으로의 체크만 가능하다는 점이다. 한 가지 기억해야 할 점은  as 연산자는 참조형 변수에 대해서만 적용할 수 있고 참조형 타입으로의 체크만 가능하다는 점이다. 
<br>

as가 형변환 결과값을 반환하는 반면 is 연산자는 형변환의 가능성 여부를 불린형의 결과값(true/false)으로 반환한다. as와 is 연산자를 언제 쓰느냐에 대한 기준은 명확하다. 형변환된 인스턴스가 필요하다면 as를 사용하고 필요없다면 is를 사용하면 된다. 

## 2. 모든 타입의 조상: System.Object