# 상속

현실 세계는 객체마다 어떤 공통적인 특징이 있고, 그 특징을 상속(inheritance)받아 다른 세부적인 항목을 정의하는데, 일상적인 많은 객체가 이러한 "꼐층적"인 관계를 따르고 있다. 
<br>

상속을 이용하면 공통적인 특징을 정의하는 부모 클래스(parent class)를 두고 자식 클래스(child class)에서 부모의 기능을 물려받는 식으로 처리할 수 있다. 
> 부모 클래스는 다른 말로 기반(base) 클래스 또는 슈퍼(super)클래스라고도 한다. 그리고 자식 클래스는 다른 말로 파생(derived) 클래스 또는 서브(sub)클래스라고도 한다. 아울러 부모 또한 부모를 가질 수 있기 때문에 조상(ancestor) 클래스라는 표현이 있으며, 반대로 자손 클래스라는 표현도 있다.
<br>

C# 클래스에서는 콜론(':')을 이용해 부모 클래스의 기능을 물려받을 수 있고 실제로 상속받은 클래스는 부모의 속성과 행위를 접근 제한자 규칙에 따라 외부에 제공한다. 
<br>

흔치 않지만 프로그래밍하다 보면 상속을 의도적으로 막고 싶을 때도 있다. 일례로 자주 쓰는 string 타입은 상속을 받지 못하도록 제한되 있는데, 이는 sealed 예약어가 적용돼 있기 때문이다. 
```cs
sealed class Pen{

}
public class ElectricPen : Pen // 컴파일 오류 발생
{

}
```
마지막으로, C#의 상속에 대해 언급해야 할 것이 있다면 단일 상속(single inheritance)만 지원한다. C#은 `계층 상속`은 가능하지만 동시에 둘 이상의 부모 클래스로부터 다중 상속을 받는 것은 허용되지 않는다. 
<br>

엄밀히 상속 자체의 개념은 부모의 기능을 물려받는 것으로 매우 간단하게 설명되지만, 그로 인해 파생되는 여러 가지 개념이 복잡하게 얽혀 있다.

## 1. 형변환
**암시적 형변환** 
특수화 타입의 변수에서 일반화된 타입의 변수로 값이 대입되는 대입되는 경우  
```cs
short a = 100; 
int b = a; //암시적 형변환 가능
```
**명시적 형변환** 
일반화 타입의 변수에서 특수화된 타입의 변수로 값이 대입되는 경우
```cs
int c = 100;
short d = (short)c; //명시적 형변환
```
이 규칙은 class로 정의된 타입의 부모/자식 관계에도 동일하게 적용된다.
<br>

특수화 타입 인스턴스를 일반화 타입의 변수로 대입하는 경우에는 암시적 형변환이 가능하지만 반대로 부모 클래스(일반화 타입)의 인스턴스를 자식 클래스(특수화 타입)의 변수로 대입하는 것은 불가능하다. 물론 강제로 캐스팅 연산자를 사용해 명시적 형변환을 하는 것은 가능하지만 실행하면 오류가 발생한다. 
<br>

부모에서 할당한 메모리에는 자식을 위한 멤버의 특성을 반영하고 있지 않다. 
<br>

그렇다면 컴파일 단계에서 명시적 형변환을 불가능하게 만들었으면 좋지 않았을까? 그렇게 할 수 없는 이유는 개발자가 의도적으로 원하는 경우도 있기 때문이다. 예를 들어, 자식 인스턴스를 가리키는 부모 클래스의 변수가 다시 자식 타입의 변수로 대입될 수 있다. 
<br>
현실적으로 볼 때 클래스 간의 명시적 형변환보다는 암시적 형변환이 좀 더 자주 사용된다. 또한 각 자식 클래스의 인스턴스를 부모 객체의 배열에 담을 수 있는 것도 암시적 형변환 덕분이다. 

### 1-1. as, is 연산자 
클래스의 형변환에서 빠질 수 없는 것이 바로 as 연산자 이다. 캐스팅 연산자를 사용해 명시적 형변환을 하는 경우 컴파일 단계가 아닌 프로그램을 실행할 때 오류가 발생한다는 것을 알았다. 닷넨 프로그램에서 오류를 발생시키는 것은 내부적으로 제법 부하가 큰 동작에 속한다. 따라서 오류를 발생시키지 않고도 형변환이 가능한지 확인할 수 있는 방법이 필요했고 이를 위해 as 연산자가 추가됐다. 
<br>

as는 형변환이 가능하면 지정된 ㅌ타입의 인스턴스 값을 반환하고, 가능하지 않으면 null 값을 반환하기 때문에 null 변환 여부를 통해 형변환이 성공했는지 판단할 수 있다. 한 가지 기억해야할 점은 as 연산자는 참조형 변수에 대해서만 적용할 수 있고 참조형 타입으로의 체크만 가능하다는 점이다. 한 가지 기억해야 할 점은  as 연산자는 참조형 변수에 대해서만 적용할 수 있고 참조형 타입으로의 체크만 가능하다는 점이다. 
<br>

as가 형변환 결과값을 반환하는 반면 is 연산자는 형변환의 가능성 여부를 불린형의 결과값(true/false)으로 반환한다. as와 is 연산자를 언제 쓰느냐에 대한 기준은 명확하다. 형변환된 인스턴스가 필요하다면 as를 사용하고 필요없다면 is를 사용하면 된다. 

## 2. 모든 타입의 조상: System.Object

클래스를 정의할 때 부모 클래스를 명시하지 않는다면 C# 컴파일러는 기본적으로 objct라는 타입에서 상속 받는다고 가정하고 자동으로 코드를 생성한다. 
<br>

결국 C#에서 정의되는 모든 클래스의 부모는 object가 된다. 따라서 C#에서 정의되는 모든 형식은 object로 변환하고 다시 되돌리는 것이 가능하다.

### 2-1 ToString
ToString 메서드를 호출하면 해당 인스턴스가 속한 클래스의 전체이름을 반환한다. 그런데 항상 그렇다고 가정할 수는 없다, 왜냐하면 ToString 메서드는 자식 크래스에서 기능을 정의할 수 있기 때문인데 string을 비롯해서 C#에서 제공되는 기본 타입(short, int, .....)은 모두 ToString을 클래스의 전체 이름이 아닌 해당 타입이 담고 있는 값을 반환하도록 변경했다. 

### 2-2 GetType
클래스(class)에 대해 생각해 보자. 클래스 역시 속성으로 클래스의 이름을 담고 있으며, 필드, 메서드, 프로퍼티와 같은 멤버를 담고 있는 또 다른 타입으로 볼 수 있다. C#에서는 개발자가 class로 타입을 정의하면 내부적으로 해당 class 타입의 정보를 가직고 있는 System.Type의 인스턴스를 보유하게 되고, 바로 그 인스턴스를 가져올 수 있는 방법이 GetType 메서드를 통해 제공된다. 
<br>

ToString 메서드가 하위 클래스에서 재정의되면 타입의 전체 이름이 아닌 값 자체를 문자열로 반환한다고 이전 절에서 설명했다. GetType 메서드는 그러한 클래스에 대해 타입의 전체 이름을 반환하는 수단을 제공한다. 
<br>

GetType은 "클래스의 인스턴스"로부터 Type을 구하는 반면, "클래스의 이름"에서 곧바로 Type을 구하는 방법도 제공되는데, 이때는 typeof라는 예약어를 사용해야 한다. 
<br>

### 2-3 Equals
Equals 메서드는 값을 비교한 결과를 불린형으로 반환한다. 
<br>

문제는 비교대상이 "값 형식"과 "참조 형식"에 대해 달라진다는 점이다. 값 형식에 대해서는 해당 인스턴스가 소유하고 있는 값을 대상으로 비교하지만 참조 형식에 대해서는 할당된 메모리 위치를 가리키는 식별자의 값이 같은지 비교한다.

> 이를 달리 표현하면 object는 할당된 메모리 위치를 가리키는 식별자의 값이 같은지를 비교하는 Equals 메서드를 제공하지만, System.ValueType의 하위 클래스는 그와 같은 기본 동작 방식을 재정의했다고 표현할 수 있다.
<br>

동일한 값을 소유한 참조 형식에 대해서 Equals 메서드는 false를 반환한다. 왜냐하면 "힙에 할당된 데이터 주소를 가리키고 있는 스택 변수의 값"을 비교하기 때문인데 이를 그림으로 설명하면 좀 더 쉽게 이해할 수 있다.
<br>

즉, new Book으로 생성된 힙 메모리의 위치가 다르기 때문에 그 안에 들어간 값이 어떤 것인지는 상관없이 Equals 메서드는 false를 반환하게 된다.
<br>

참조 형식에 대한 Equals 메서드의 이 같은 동작 방식이 과연 실용성이 있는지 궁금할 수 도 있다. 이 때문에 object는 하위 클래스에서 Equals에 대한 동작 방식을 재정의할 수 있도록 허용한다. 한 가지 좋은 예가 바로 그동안 자주 사용해왔던 string 참조 타입이다. 

### 2-4 GetHashCode
GetHashCode 메서드는 특정 인스턴스를 고유하게 식별할 수 있는 4바이트 int값을 반환한다. 한 가지 기억해 둬야 할 점은 GetHashCode가 Equals 메서드와 연계되는 특성이 있다는 점이다. Equals의 반환값이 true인 객체라면 서로 같음을 의미하고, 그렇다면 그 객체들을 식별하는 고윳값 또한 같아야 한다. 반면 Equals 반환값이 false라면 GetHashCode의 반환값도 달라야 한다. 이 때문에 보통 Equals 메서드를 하위 클래스에 재정의하면 GetHashCode까지 재정의하는데, 이를 따르지 않으면 컴파일 경고가 발생한다. 
<br>

object에서 정의된 GetHashCode는 참조 타입에 대해 기본 동작을 정의해 뒀는데, 생성된 참조형 타입의 인스턴스가 살아 있는 동안 닷넷 프레임워크 내부에서 그러한 인스턴스에 부여한 식별자 값을 반환하기 때문에 적어도 프로그램이 실행되는 중에 같은 타입의 다른 인스턴스와 GetHashCode 반환값이 겹칠 가능성은 많지 않다. 값 타입에 대해서는 GetHashCode의 동작 방식을 재정의해서 해당 인스턴스가 동일한 값을 가지고 있다면 같은 해시코드를 반환한다. 

## 3. 모든 배열의 조상: System.Array
object가 모든 타입의 조상인 것처럼 소스코드에 정의되는 배열은 모든 Array 타입을 조상으로 둔다. 예를 들어, 다음과 같이 배열을 정의한 경우
```cs
int[] intArray = new int[] {0,1,2,3,4,5};
```
C# 컴파일러는 자동적으로 int [] 타입을 Array 타입으로 상속받는 것으로 처리한다. 이로 인해 배열 인스턴스는 Array 타입이 가진 모든 특징을 제공하는데, 일부 속성 및 메서드는 알아두면 유용하므로 여기서 짚고 넘어가자.
<br>
* `Rank` 
    *  인스턴스 프로퍼티 
        * 배열 인스턴스의 차원(dimension) 수를 반복한다
* `Length`
    * 인스턴스 프로퍼티
        * 배열 인스턴스의 요소(element) 수를 반환한다
* `Sort`
    * 정적 메서드
        * 배열 요소를 값의 순서대로 정렬한다.
* `GetValue` 
    * 인스턴스 메서드
        * 지정된 인덱스의 배열 요소 값을 반환한다
* `Copy`
    * 정적 메서드
        * 배열의 내용을 다른 배열에 복사한다
        

