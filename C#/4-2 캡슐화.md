# 캡슐화
관련성 있는 데이터와 그 데이터를 다루는 메서드를 객체 안에 구현하는 것이 일반적인 통념이고, 더 나아가서는 객체의 밖에서 알아야 할 필요가 없는 내부 멤버를 숨기기도 하는데, 이를 두고 캡슐화(encapsulation)라는 용어를 상용한다.
<br>

사실 객체가 없던 시절에는 데이터와 코드가 한 군데에 묶일 구심점이 없었다. 객체가 없으면 그나마 파일로 구분해 줄 수 있는데, 예를 들어 모든 코드를 main.c라는 파일안에 넣어 줄 수 있다. 어찌보면 파일로 구분 한 것도 일종의 캡슐화라고 볼 수 있지만, 여기에는 명백히 다음과 같은 단점이 있다. 
<br>

* 변수 pi를 파일 내의 모든 함수에서 접근할 수 있다. 다른 파일에서도 접근할 수 있게 돼 있다면 역시 모든 파일의 함수에서 읽고 쓰는 것이 가능하다. 

* 다른 파일에서는 특정 함수만 쓰도록 강제할 수 없다. 

이 같은 문제는 객체지향 프로그래밍에서 클래스를 통해 캡슐화하면 쉽게 해결된다.
<br>

캡슐화가 잘 된 클래스는 그것을 사용하는 입장에서도 편리하다는 장점이 있다. 클래스의 이름 자체에서 이미 제공되는 기능을 대략 파악할 수 있고, 외부로 제공해야 할 기능에 대해서만 정확하게 public으로 노출한다. 함수가 블랙박스였던 것처럼 클래스 역시 객체의 역할을 추상화한다.
<br>

## 1. 접근 제한자 
* **private** : 내부에서만 접근을 하용한다. 
* **protected** : 내부에서의 접근과 함께 파생 클래스에서만 접근을 허용한다.
* **public** : 내부 및 파생 클래스에서 접근뿐만 아니라 외부에서도 접근을 허용한다. 
* **internal** : 동일한 어셈블리 내에서는 public에 준한 접근을 허용한다. 다른 어셈블리에서는 접근할 수 없다. 
* **internal protect** : 동일한 어셈블리 내에서 정의된 클래스이거나 다른 어셈블리라면 파생 클래스인 경우에 한해 접근을 허용한다.

접근 제한자가 적용되는 곳은 클래스와 구조체, 인터페이스가 있고 그것들의 멤버까지 허용된다. 
<br>

접근 제한자의 그 밖의 특징으로는 명시되지 않은 경우에 기본적으로 갖게되는 제한자가 정의돼 있다는 점이다. 예를 들어 class 정의에서 접근 제한자를 생략한 경우 기본적으로 internal로 설정되는 반면, class 내부의  멤버에 대해서는 private으로 설정한다.
<br>

대부분의 경우 private와 public만으로 충분하고, 설령 개발자가 접근제한자를 잘못 설명해도 C# 컴파일러가 명시적으로 에러를 발생시키므로 곧바로 인식할 수 있다.

## 2. 정보 은닉
객체지향에서 캡슐화를 다룰 때면 언제나 정보 은닉(information hiding)이라는 개념이 함께 등장한다. 클래스 입장에서 "정보"라고 불리는 것은 멤버 변수를 일컫는데, 외부에서 이 멤버 변수를 직접 접근할수 없게 만드는 것이 바로 정보 은닉에 해당한다. 일반적으로 캡슐화를 잘 했다면 정보 은닉도 함께 지켜지는 것이 보통이지만 그 역은 성립할 수 없다. 즉, 온갖 잡다한 기능을 넣은 클래스에서도 멤버 변수를 외부에 노출시키지 않는다면 정보 은닉이 성립하기 때문이다. 
<br>

접근자와 설정자를 모두 만들어 준다면 차라리 멤버 변수를 public으로 만드는 편이 더 쉽지 않을까? 하고 생각할 수 있다. 오직 필드의 값을 읽고 쓰는데만 관심이 있다면 굳이 접근자/설정자 메서드를 둘 필요가 없다. 사실 접근자/설정자 메서드가 나오게 된 이유 중 하나는 향후 코드에 대한 유지보수를 쉽게 하기 위해서다. 설정자 메서드 없이 필드로 직접 노출했다면 문제가 발생 시에 그 필드를 사용하는 코드를 모조리 찾아야 한다. 반면 설정자 메서드를 정의해서 사용하고 있었다면 설정자 메서드에 진단 목적의 코드를 넣어서 문제를 쉽게 발견할 수 있다. 
<br>

나중에 호출 스택(call stack)을 구하는 방법이나 통합 개발 환경 등을 이용해 디버거(debugger)를 사용할 수 있는 때가 되면 설정자 메서드를 구현해 뒀을 때 훨씬 쉽게 문제를 파악할 수 있다. 
<br>

정보 은닉의 원칙은 간단하다. 
* 특별한 이유를 제외하고는 필드를 절대 public으로 설정하지 않는다.
* 접근이 필요할 때는 접근자/설정자 메서드를 만들어 외부에서 접근하는 경로를 클래스 개발자의 관리하에 둔다.

## 3. 프로퍼티
접근자/설정자 메서드를 둬서 필드 접근에 대한 단일 창구를 제공하는 것은 바람직하지만 호출을 위한 메서드 정의를 일일이 코드로 작성하자면 분명 번거로울 것이다. 이 같은 단점으로 보완하기 위해 C# 에서는 특별히 프로퍼티(property)라는 문법을 제공한다. 

```cs
class 클래스_명
{
    접근_제한자 타입 프로퍼티_명{
        접근_제한자 get{
            //.....[코드]......
            return 프로퍼티의_타입과_일치하는_유형의_표현식;
        }
        접근_제한자 set{
            //value라는 문맥 키워드를 사용해 설정하려는 값을 표현
        }
    }

}
```
Pi 프로퍼티의 정의를 보면 대체로 어렵지 않게 이해할 수 있지만 set의 value는 도대체 어디서 온 것일까? 설정자 메서드는 사용자가 전달하는 값을 매개변수명으로 구분할 수 있지만 프로퍼티 정의에서는 매개변수가 없으므로 C# 컴파일러가 프로퍼티에 대입되는 값을 가리킬 수 없다는 문제가 발생한다. 이 문제를 해결하기 위해 별도로 set 불록 내부에세만 사용할 수 있는 "value" 예약어가 도입된 것이다. 
<br>

읽기 전용 프로퍼티는 간단하게 set 불록의 코드만 제거하면 구현할 수 있다. 또한 get/set에도 접근 제한자를 지정할 수 있기 때문에 때로는 set을 없애지 않고 private으로 설정할 때도 있다. 그럼 클래스 내부에서는 해당 프로퍼티의 set 구문을 사용할 수 있으면서도 외부에서는 설정할 수 없기 때문에 적절한 캡슐화 수준을 유지 할 수 있다. 
<br>

마지막으로 프로퍼티는 메서드의 특수한 변형에 불과하다는 사실을 알아두자. 
C#의 프로퍼티는 접근자/설정자 메서드를 간편하게 만들어주는 도우미 성격의 구문일 뿐이다. 

> 외국 개발자들은 이를 두고 `synatic suger`라는 표현을 쓰기도 한다. 전형적인 개발자다운 표현으로 그들에게는 프로그래밍 새계에서 귀찮은 작업을 편리하게 만들어주는 요소라면 그곳이 현실 세계의 설탕에 비유할 수 있지 않을까 하는 생각에서 이런 말을 만들어 낸 것 같다.

