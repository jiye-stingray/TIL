# 5-4. 힙과 스택
일반적으로 프로그램을 실행하면 프로그램의 코드는 메모리에 적재된다. 메모리 상의 코드는 CPU에 의해 하나씩 읽혀지면서 실행되는데, 이 과정에서 프로그램은 자연스럽게 데이터를 위한 메모리가 필요해진다. 따라서 메모리는 코드(Code)와 데이터(Data)로 채워진다. 
<br>
힙과 스택은 데이터를 위한 메모리라는 점에서 같은 성질을 띤다. 단지 메모리의 용도에 따라 구분 된다.


## 1. 스택
스택(stack)은 스레드가 생성되면 기본적으로 1MB의 용량으로 스레드마다 할당되고, 이름에서 알 수 있듯이 자료구조에서 다루는 스택과 동작 방식이 같다. 이 스택 공간을 활용해서 스레드는 메서드의 실행, 해당 메서드로 전달하는 인자, 메서드 내에서 사용되는 지역 변수를 처리한다. 예를 들어, 다음의 간단한 프로그램을 통해 스레드가 Sum 메서드를 실행하면서 스택이 어떻게 바뀌는지 보자.

```cs
static void Main(string[] args)
{
    int result = Sum(5,6);
    Console.WriteLine(result);
}

private static int Sum(int v1, int v2)
{
    int v3 = v1 + v2;
    return v3;
}
```
<br>

스레드가 Sum 메서드를 호출하는 과정에서 스레드에 할당된 스택에 5와 6의 4바이트 정숫값과 Sum 메서드를 호출한 후 실행이 재개될 Main 메서드의 코드 주소를 넣어둔다.

> 스택 연산을 순서대로 표현하면 다음과 같다. <br>
> PUSH 5 <BR>
> PUSH 6 <BR>
> PUSH [Sum 메서드 호출 후 실행될 주소] <br>
> 그런데 메모리 상의 표현으로 보면 거꾸로 쌓여 있다는 점이 혼란스러울 수 있다. 스레드의 스택은 상위 주소에서 하위 주소로 자라기 때문에 먼저 PUSH한 값일수록 상위 주소에 위치한다. 

<br>
<br>
스레드는 메서드의 코드를 실행하기 전에 지역 변수를 위한 메모리를 추가로 스택에 할당하는 과정을 거친다. 지역 변수에 필요한 메모리의 양은 C# 컴파일러가 Sum 메서드를 컴파일하는 과정에서 알 수 있고, 위의 예제에서는 int v3 하나이므로 4바이트 공간을 확보해 둔다. 
<br>
Sum 메서드의 실행이 완료되면 이제 차레대로 스택에서 값들이 제거되는 과정을 거친다. C# 컴파일러는 지역 변수로 할당된 공간이 4바이트임을 알고 있기 때문에 이를 다시 제거하는 명령어를 이미 컴파일 과정에 넣어둔다. Sum 메서드의 실행을 완료한 CPU는 "Sum 메서드를 호출한 후 실행될 주소" 값을 스택에서 꺼낸 후 실행을 이어간다. 또한 Sum 메서드에 전달된 인자가 2개라는 사실도 C# 컴파일러는 알고 있었기 때문에 Sum 메서드를 실행한 후에 5와 6을 위해 할당된 2개의 4바이트 스택을 제거하는 명령어도 컴파일 과정에서 넣어둔 상태다.
<br>
결과적으로, Sum 메서드를 호출하기 전과 호출 후의 스택에는 변함이 없다. 이처럼 스택은 그것이 속한 스레드가 메서드 호출을 할 때마다 증가하고 줄어드는 과정을 반복한다. 스택 자료구조 하나만으로 인자 전달과 지역 변수, 메서드의 실행 흐름을 제어할 수 있게 된 것이다. 
<br>
<br>

> 이 절에서 설명한 메서드 호출과 스택의 관계는 실제 동작과는 다소 차이가 있다. 단지 개념적으로 그렇게 동작한다는 것으로만 이해해 두자.

### 1-1. 스택 오버플로
스택은 기본적으로 1MB 공간만 스레드에 할당한다. 1MB 용량은 경우에 따라 매우 클 수도 있고 작을 수도 있다. 위에서 예제로 든 Sum 메서드는 한번 호출할 때마다 16바이트 정도의 스택이 사용된다. 다소 억지스러운 예지만, 예시를 다음과 같이 수정해보자.
<br>

```cs
static void Main(string[] args)
{
    int result = Sum(5,6);
    Console.WriteLine(result);
}

private static int Sum(int v1, int v2)
{
    int sum = InnerSum(v1, v2);
    return sum;
}

private static int InnerSum(int v1, int v2)
{
    int sum = v1 + v2;
    return sum;
}

```
<br>

Sum은 또 다시 InnerSum 메서드를 호출하고 있다. 2개의 메서드 모두 2개의 인자를 받고, 1개의 지역 변수를 사용하고 있으므로 각 호출마다 16바이트의 스택 메모리를 소비한다. Main -> Sum -> InnerSum 호출이 중첩됐기 때문에 InnerSum 코드를 실행하는 동안에는 스택에 32바이트가 점유된 것이다. 
<br>

이처럼 스택은 메서드 호출이 깊어질수록 그와 함께 스택 사용량도 늘어난다. 그런데 만약 메서드 콜스택이 많이 쌓여서 1MB 용량을 넘는 상황도 있지 않을까? 바로 그런 상황을 가리켜 "스택 오버플로(stack overflow)가 발생했다"라고 한다. 이 예외가 발생하면 프로그램은 try/catch 유무에 상관없이 비정상적으로 종료된다. 
<br>

다행이 1MB라는 용량은 일반적인 메서드 호출 상황에서 스택 오버플로를 발생시키기에는 꽤나 여유가 있는 공간이다. 하지만 재귀 호출을 사용하는 프로그램에서는 문제가 발생할 수 있다. 

## 1-2. 재귀 호출
재귀 호출(recursive call)이란 메서드 내에서 자기 자신을 다시 호출하는 것을 말한다. 재귀 호출을 이야기 할 때 흔히 드는 예가 바로 계승(factorial)을 구하는 코드다. 

```cs
static void Main(string[] args)
{
    Console.WriteLine(factrial(5)); // 출력 결과: 120 (계승: 5 * 4 * 3 * 2 * 1 == 120)
}

private static long factorial(long n)
{
    if(n == 0) return 1;

    return n * factorial(n - 1);
}
```
보다시피 factorial 메서드 내에서 다시 factorial을 호출한다. 이때 메서드의 호출 과정을 짚어 보자.

> 1. 최초 factorial(5) 호츌 시, n == 0이 아니므로 다시 factorial(5 - 1)을 호출한다. 
> 2. factorial(4) 호출 시, n == 0이 아니므로 다시 factorial(4 - 1)을 호출한다. 
> 3. factorial(3) 호출 시, n == 0이 아니므로 factorial(3 - 1)을 호출한다. 
> 4. factorial(2) 호출 시, n == 0이 아니므로 factorial(2 - 1)을 호출한다. 
> 5. factorail(1) 호출 시, n == 0이 아니므로 factorial(1 - 1)을 호출한다.
> 6. 마침내 factorial(0) 호출 시, n == 0 이므로 1을 반환한다. 
<br>

이제 프로그램 제어는 6번부터 거슬러서 올라간다. 즉, 6번 과정에서 호출된 factorial(0)은 1을 반환하고, 5번 호출이 수행된 시점으로 프로그램 실행이 넘어간다.
<br>

* 5번의 호출 평가 : return 1 * factorial(1 - 1)코드가 수행된다. factorial(1 - 1)은 1을 반환하므로 return 1 * 1이 된다. 
<br>

* 4번의 호출 평가 : return 2 * factorial(2 - 1)코드가 수행된다. factorial(2 - 1)은 5번의 호출 평가에 따라 1을 반환한다. 따라서 2 * 1이 되어 2가 반환된다.
<br>

* 3번의 호출 평가 : return 3 * factorial(3 - 1)코드가 수행된다. factorial(3 - 1)은 4번의 호출 평가에 따라 2을 반환한다. 따라서 3 * 2이 되어 6이 반환된다.
<br>

* 2번의 호출 평가 : return 4 * factorial(4 - 1)코드가 수행된다. factorial(4 - 1)은 3번의 호출 평가에 따라 6을 반환한다. 따라서 4 * 6이 되어 24가 반환된다.
<br>

* 1번의 호출 평가 : return 5 * factorial(5 - 1)코드가 수행된다. factorial(5 - 1)은 2번의 호출 평가에 따라 24을 반환한다. 따라서 5 * 24이 되어 120이 반환된다.
<br>
<br>

처음에는 재귀 호출이 복잡해 보일 수 있지만 어떤 경우에는 재귀 호출을 사용하지 않으면 오히려 더 복잡해지는 경우가 있다.
<br>

재귀 호출의 단점이라면 콜 스택이 과다하게 쌓이는 경우 1MB의 스택 용량을 넘어설 수 있다는 것이다.
<br>
재귀함수로 스택 오버플로 예외가 발생한 경우, 콜 스택 정보와 소스코드의 라인 정보가 출력되지 않는다. 왜냐하면 이미 스택 메모리가 모두 소비됐기 때문에 그 상황에서 오류 상황을 알리는 메서드를 호출할 수 없기 때문이다. 그 메서드조차도 호출하는 데 스택을 소비하므로 정확한 오류 상황을 보고할 수 없다. 이 떄문에 스택 오버플로 예외는 한번 발생하면 그 원인을 파악하기가 매우 어렵다. 
<br>
한 가지 다행인 점은 웬만큼 특이한 상황이 아니고서는 상용 프로그램에서조차 콜 스택이 깊어져서 1MB 용량을 소진하는 경우는 거의 없다는 것이다. 보통 스택 오버플로 예외는 재귀 호출을 잘못 만들었거나 재귀 호출을 너무 많이 발생시키는 상황이 주된 원인이다. 재귀 호출이 스택 오버플로 문제를 겪는다면 스택 용량을 늘리거나 아니면 기존의 재귀 호출 코드를 사용하지 않는 코드로 바꾸는 방법을 고려해 볼 수 있다.
<br>
<br>

## 2. 힙
힙(heap)의 경우 별도로 명시하지 않는 한 CLR에서는 관리 힙(managed heap)을 가리킨다. 관리 힙이란 CLR의 가비지 수집기(GC: Garbage Collector)가 할당/해제를 관리하기 때문에 붙여진 이름이다. C#에서 new로 할당되는 모든 참조형 객체는 힙에 할당된다. 이전에 설명한 대로 C#에서 new로 할당된 메모리를 직접적으로 해제하는 명령어는 없다. 왜냐하면 해제는 GC가 자동으로 해주기 때문이다.
<br>

네이티브 응용 프로그램에서는 할당과 해제를 개발자가 주의 깊게 쌍을 맞춰야 한다. 할당만 하고 해제를 잊어버리면 점차 해재되지 않은 메모리가 누적되어 나중에는 메모리 부족 현상이 이를 메모리 누수 현상(memory leak)이라 한다. 관리 응용 프로그램에서는 GC 덕분에 메모리 누수 현상을 겪을 위험은 많이 줄어들었다. 하지만 여전히 힙의 특성을 아는 것이 중요하다. 
<br>

C# 프로그램은 코드가 실행되면서 new로 필요한 객체를 힙에 할당한다. 물론 메모리는 무한대로 쓸 수 있는 자원이 아니다. 따라서 일정 수준의 메모리 할당이 발생하면 GC가 동작한다. GC는 힙에 있는 객체 중에서 현재 사용되지 않는 객체는 제거해 버림으로써 여유 공간을 확보한다. 아쉽게도 GC의 동작은 프로그램의 다른 동작을 중지 시킨다는 것을 염두해 둬야 한다. 즉, 힙을 많이 사용할수록 GC는 더 자주 동작하고 그만큼 프로그래램은 빈번하게 실행이 중지되어 심각한 성능 문제를 겪을 수 있다.

### 2-1. 박싱/언박싱
값 형식을 참조 형식으로 변환하는 것을 박싱(boxing)이라고 하며, 그 반대를 언박싱(unboxing)이라고 한다. 이런 변환 과정은 object 타입과 System.ValueType을 상속받은 값 형식의 인스턴스를 섞어 쓰는 경우에 발생한다. 

```cs
static void Main(string[] args)
{
    int a = 5;

    object obj = a;     // 박싱: 값 형식인 int를 참조 형식인 object에 대입

    int b = (int)obj;   // 언박싱: 참조 형식인 object를 값 형식인 int에 대입
}
```
<br>
그런데 박싱과 언박싱이 별도로 언급될 만큼 중요한 이유는 뭘까? 위의 코드가 실행되는 과정을 천천히 짚어보자. 
<br>

1. int a = 5; 코드에서 a는 지역 변수다. 따라서 스택 메모리에는 5라는 값이 들어간다.
<br>

2. object obj = a; 코드에서 obj는 지역 변수이고 스택에 할당된다. 하지만 object가 참조형이기 때문에 힙에도 메모리가 할당되고 변수 a의 값이 들어간다.  즉, 박싱이 발생한 것이다. obj 지역 변수는 힙에 할당된 주소를 가리킨다. 
<br>

3. int b = (int)obj; 코드에서 b는 지역 변수다. 따라서 스택 메모리에 b 영역이 있고, 힙 메모리에 있는 값을 스택 메모리로 복사한다. (언박싱)
<br>

보다시피 값 형식을 object로 형변환하는 것은 힙에 메모리를 할당하는 작업을 동반한다. 이와 유사한 경우가 메서드에 인자를 전달할 때 발생한다. 

```cs
static void Main(string[] args)
{
    int a = 5;
    int b = 6;

    int c = GetMaxValue(a, b);
}

private  static int GetMaxValue(object v1, object v2)
{
    int a =  (int)v1;
    int b = (int)v2;

    if(a >= b)
    {
        return a;
    }    

    return b;
}
```
GetMaxValue의 v1, v2 매개변수는 object 참조형이므로 힙에 메모리를 할당하고, 전달된 a, b의 값을 복사한다. 박싱이 발생한 것이다. 만약 GetMaxValue의 v1, v2 매개변수가 int 형이 였다면 스택의 값 복사만으로 끝날 수 있는 문제였지만 박싱으로 인해 관리 힙을 사용하게 됐고, 이는 GC에게 일을 시키게 만든다. 즉, 박싱이 빈번할수록 GC는 바빠지고 프고그램의 수행 성능은 그만큼 떨어진다. 따라서 박싱을 과다하게 발생시킬 수 있는 코드는 최대한 줄이는 것을 권장한다. 
<br>











