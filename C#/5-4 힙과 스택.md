# 5-4. 힙과 스택
일반적으로 프로그램을 실행하면 프로그램의 코드는 메모리에 적재된다. 메모리 상의 코드는 CPU에 의해 하나씩 읽혀지면서 실행되는데, 이 과정에서 프로그램은 자연스럽게 데이터를 위한 메모리가 필요해진다. 따라서 메모리는 코드(Code)와 데이터(Data)로 채워진다. 
<br>
힙과 스택은 데이터를 위한 메모리라는 점에서 같은 성질을 띤다. 단지 메모리의 용도에 따라 구분 된다.


## 1. 스택
스택(stack)은 스레드가 생성되면 기본적으로 1MB의 용량으로 스레드마다 할당되고, 이름에서 알 수 있듯이 자료구조에서 다루는 스택과 동작 방식이 같다. 이 스택 공간을 활용해서 스레드는 메서드의 실행, 해당 메서드로 전달하는 인자, 메서드 내에서 사용되는 지역 변수를 처리한다. 예를 들어, 다음의 간단한 프로그램을 통해 스레드가 Sum 메서드를 실행하면서 스택이 어떻게 바뀌는지 보자.

```cs
static void Main(string[] args)
{
    int result = Sum(5,6);
    Console.WriteLine(result);
}

private static int Sum(int v1, int v2)
{
    int v3 = v1 + v2;
    return v3;
}
```
<br>

스레드가 Sum 메서드를 호출하는 과정에서 스레드에 할당된 스택에 5와 6의 4바이트 정숫값과 Sum 메서드를 호출한 후 실행이 재개될 Main 메서드의 코드 주소를 넣어둔다.

> 스택 연산을 순서대로 표현하면 다음과 같다. <br>
> PUSH 5 <BR>
> PUSH 6 <BR>
> PUSH [Sum 메서드 호출 후 실행될 주소] <br>
> 그런데 메모리 상의 표현으로 보면 거꾸로 쌓여 있다는 점이 혼란스러울 수 있다. 스레드의 스택은 상위 주소에서 하위 주소로 자라기 때문에 먼저 PUSH한 값일수록 상위 주소에 위치한다. 

<br>
<br>
스레드는 메서드의 코드를 실행하기 전에 지역 변수를 위한 메모리를 추가로 스택에 할당하는 과정을 거친다. 지역 변수에 필요한 메모리의 양은 C# 컴파일러가 Sum 메서드를 컴파일하는 과정에서 알 수 있고, 위의 예제에서는 int v3 하나이므로 4바이트 공간을 확보해 둔다. 
<br>
Sum 메서드의 실행이 완료되면 이제 차레대로 스택에서 값들이 제거되는 과정을 거친다. C# 컴파일러는 지역 변수로 할당된 공간이 4바이트임을 알고 있기 때문에 이를 다시 제거하는 명령어를 이미 컴파일 과정에 넣어둔다. Sum 메서드의 실행을 완료한 CPU는 "Sum 메서드를 호출한 후 실행될 주소" 값을 스택에서 꺼낸 후 실행을 이어간다. 또한 Sum 메서드에 전달된 인자가 2개라는 사실도 C# 컴파일러는 알고 있었기 때문에 Sum 메서드를 실행한 후에 5와 6을 위해 할당된 2개의 4바이트 스택을 제거하는 명령어도 컴파일 과정에서 넣어둔 상태다.
<br>
결과적으로, Sum 메서드를 호출하기 전과 호출 후의 스택에는 변함이 없다. 이처럼 스택은 그것이 속한 스레드가 메서드 호출을 할 때마다 증가하고 줄어드는 과정을 반복한다. 스택 자료구조 하나만으로 인자 전달과 지역 변수, 메서드의 실행 흐름을 제어할 수 있게 된 것이다. 
<br>
<br>

> 이 절에서 설명한 메서드 호출과 스택의 관계는 실제 동작과는 다소 차이가 있다. 단지 개념적으로 그렇게 동작한다는 것으로만 이해해 두자.

### 1-1. 스택 오버플로
스택은 기본적으로 1MB 공간만 스레드에 할당한다. 1MB 용량은 경우에 따라 매우 클 수도 있고 작을 수도 있다. 위에서 예제로 든 Sum 메서드는 한번 호출할 때마다 16바이트 정도의 스택이 사용된다. 다소 억지스러운 예지만, 예시를 다음과 같이 수정해보자.
<br>

```cs
static void Main(string[] args)
{
    int result = Sum(5,6);
    Console.WriteLine(result);
}

private static int Sum(int v1, int v2)
{
    int sum = InnerSum(v1, v2);
    return sum;
}

private static int InnerSum(int v1, int v2)
{
    int sum = v1 + v2;
    return sum;
}

```
<br>

Sum은 또 다시 InnerSum 메서드를 호출하고 있다. 2개의 메서드 모두 2개의 인자를 받고, 1개의 지역 변수를 사용하고 있으므로 각 호출마다 16바이트의 스택 메모리를 소비한다. Main -> Sum -> InnerSum 호출이 중첩됐기 때문에 InnerSum 코드를 실행하는 동안에는 스택에 32바이트가 점유된 것이다. 
<br>

이처럼 스택은 메서드 호출이 깊어질수록 그와 함께 스택 사용량도 늘어난다. 그런데 만약 메서드 콜스택이 많이 쌓여서 1MB 용량을 넘는 상황도 있지 않을까? 바로 그런 상황을 가리켜 "스택 오버플로(stack overflow)가 발생했다"라고 한다. 이 예외가 발생하면 프로그램은 try/catch 유무에 상관없이 비정상적으로 종료된다. 
<br>

다행이 1MB라는 용량은 일반적인 메서드 호출 상황에서 스택 오버플로를 발생시키기에는 꽤나 여유가 있는 공간이다. 하지만 재귀 호출을 사용하는 프로그램에서는 문제가 발생할 수 있다. 

## 1-2. 재귀 호출
재귀 호출(recursive call)이란 메서드 내에서 자기 자신을 다시 호출하는 것을 말한다. 재귀 호출을 이야기 할 때 흔히 드는 예가 바로 계승(factorial)을 구하는 코드다. 

```cs
static void Main(string[] args)
{
    Console.WriteLine(factrial(5)); // 출력 결과: 120 (계승: 5 * 4 * 3 * 2 * 1 == 120)
}

private static long factorial(long n)
{
    if(n == 0) return 1;

    return n * factorial(n - 1);
}
```
보다시피 factorial 메서드 내에서 다시 factorial을 호출한다. 이때 메서드의 호출 과정을 짚어 보자.

> 1. 최초 factorial(5) 호츌 시, n == 0이 아니므로 다시 factorial(5 - 1)을 호출한다. 
> 2. factorial(4) 호출 시, n == 0이 아니므로 다시 factorial(4 - 1)을 호출한다. 
> 3. factorial(3) 호출 시, n == 0이 아니므로 factorial(3 - 1)을 호출한다. 
> 4. factorial(2) 호출 시, n == 0이 아니므로 factorial(2 - 1)을 호출한다. 
> 5. factorail(1) 호출 시, n == 0이 아니므로 factorial(1 - 1)을 호출한다.
> 6. 마침내 factorial(0) 호출 시, n == 0 이므로 1을 반환한다. 
<br>

이제 프로그램 제어는 6번부터 거슬러서 올라간다. 즉, 6번 과정에서 호출된 factorial(0)은 1을 반환하고, 5번 호출이 수행된 시점으로 프로그램 실행이 넘어간다.
<br>

* 5번의 호출 평가 : return 1 * factorial(1 - 1)코드가 수행된다. factorial(1 - 1)은 1을 반환하므로 return 1 * 1이 된다. 
<br>

* 4번의 호출 평가 : return 2 * factorial(2 - 1)코드가 수행된다. factorial(2 - 1)은 5번의 호출 평가에 따라 1을 반환한다. 따라서 2 * 1이 되어 2가 반환된다.
<br>

* 3번의 호출 평가 : return 3 * factorial(3 - 1)코드가 수행된다. factorial(3 - 1)은 4번의 호출 평가에 따라 2을 반환한다. 따라서 3 * 2이 되어 6이 반환된다.
<br>

* 2번의 호출 평가 : return 4 * factorial(4 - 1)코드가 수행된다. factorial(4 - 1)은 3번의 호출 평가에 따라 6을 반환한다. 따라서 4 * 6이 되어 24가 반환된다.
<br>

* 1번의 호출 평가 : return 5 * factorial(5 - 1)코드가 수행된다. factorial(5 - 1)은 2번의 호출 평가에 따라 24을 반환한다. 따라서 5 * 24이 되어 120이 반환된다.
<br>
<br>

처음에는 재귀 호출이 복잡해 보일 수 있지만 어떤 경우에는 재귀 호출을 사용하지 않으면 오히려 더 복잡해지는 경우가 있다.
<br>

재귀 호출의 단점이라면 콜 스택이 과다하게 쌓이는 경우 1MB의 스택 용량을 넘어설 수 있다는 것이다.
<br>
재귀함수로 스택 오버플로 예외가 발생한 경우, 콜 스택 정보와 소스코드의 라인 정보가 출력되지 않는다. 왜냐하면 이미 스택 메모리가 모두 소비됐기 때문에 그 상황에서 오류 상황을 알리는 메서드를 호출할 수 없기 때문이다. 그 메서드조차도 호출하는 데 스택을 소비하므로 정확한 오류 상황을 보고할 수 없다. 이 떄문에 스택 오버플로 예외는 한번 발생하면 그 원인을 파악하기가 매우 어렵다. 
<br>
한 가지 다행인 점은 웬만큼 특이한 상황이 아니고서는 상용 프로그램에서조차 콜 스택이 깊어져서 1MB 용량을 소진하는 경우는 거의 없다는 것이다. 보통 스택 오버플로 예외는 재귀 호출을 잘못 만들었거나 재귀 호출을 너무 많이 발생시키는 상황이 주된 원인이다. 재귀 호출이 스택 오버플로 문제를 겪는다면 스택 용량을 늘리거나 아니면 기존의 재귀 호출 코드를 사용하지 않는 코드로 바꾸는 방법을 고려해 볼 수 있다.
<br>
<br>

## 2. 힙
힙(heap)의 경우 별도로 명시하지 않는 한 CLR에서는 관리 힙(managed heap)을 가리킨다. 관리 힙이란 CLR의 가비지 수집기(GC: Garbage Collector)가 할당/해제를 관리하기 때문에 붙여진 이름이다. C#에서 new로 할당되는 모든 참조형 객체는 힙에 할당된다. 이전에 설명한 대로 C#에서 new로 할당된 메모리를 직접적으로 해제하는 명령어는 없다. 왜냐하면 해제는 GC가 자동으로 해주기 때문이다.
<br>

네이티브 응용 프로그램에서는 할당과 해제를 개발자가 주의 깊게 쌍을 맞춰야 한다. 할당만 하고 해제를 잊어버리면 점차 해재되지 않은 메모리가 누적되어 나중에는 메모리 부족 현상이 이를 메모리 누수 현상(memory leak)이라 한다. 관리 응용 프로그램에서는 GC 덕분에 메모리 누수 현상을 겪을 위험은 많이 줄어들었다. 하지만 여전히 힙의 특성을 아는 것이 중요하다. 
<br>

C# 프로그램은 코드가 실행되면서 new로 필요한 객체를 힙에 할당한다. 물론 메모리는 무한대로 쓸 수 있는 자원이 아니다. 따라서 일정 수준의 메모리 할당이 발생하면 GC가 동작한다. GC는 힙에 있는 객체 중에서 현재 사용되지 않는 객체는 제거해 버림으로써 여유 공간을 확보한다. 아쉽게도 GC의 동작은 프로그램의 다른 동작을 중지 시킨다는 것을 염두해 둬야 한다. 즉, 힙을 많이 사용할수록 GC는 더 자주 동작하고 그만큼 프로그래램은 빈번하게 실행이 중지되어 심각한 성능 문제를 겪을 수 있다.

### 2-1. 박싱/언박싱
값 형식을 참조 형식으로 변환하는 것을 박싱(boxing)이라고 하며, 그 반대를 언박싱(unboxing)이라고 한다. 이런 변환 과정은 object 타입과 System.ValueType을 상속받은 값 형식의 인스턴스를 섞어 쓰는 경우에 발생한다. 

```cs
static void Main(string[] args)
{
    int a = 5;

    object obj = a;     // 박싱: 값 형식인 int를 참조 형식인 object에 대입

    int b = (int)obj;   // 언박싱: 참조 형식인 object를 값 형식인 int에 대입
}
```
<br>
그런데 박싱과 언박싱이 별도로 언급될 만큼 중요한 이유는 뭘까? 위의 코드가 실행되는 과정을 천천히 짚어보자. 
<br>

1. int a = 5; 코드에서 a는 지역 변수다. 따라서 스택 메모리에는 5라는 값이 들어간다.
<br>

2. object obj = a; 코드에서 obj는 지역 변수이고 스택에 할당된다. 하지만 object가 참조형이기 때문에 힙에도 메모리가 할당되고 변수 a의 값이 들어간다.  즉, 박싱이 발생한 것이다. obj 지역 변수는 힙에 할당된 주소를 가리킨다. 
<br>

3. int b = (int)obj; 코드에서 b는 지역 변수다. 따라서 스택 메모리에 b 영역이 있고, 힙 메모리에 있는 값을 스택 메모리로 복사한다. (언박싱)
<br>

보다시피 값 형식을 object로 형변환하는 것은 힙에 메모리를 할당하는 작업을 동반한다. 이와 유사한 경우가 메서드에 인자를 전달할 때 발생한다. 

```cs
static void Main(string[] args)
{
    int a = 5;
    int b = 6;

    int c = GetMaxValue(a, b);
}

private  static int GetMaxValue(object v1, object v2)
{
    int a =  (int)v1;
    int b = (int)v2;

    if(a >= b)
    {
        return a;
    }    

    return b;
}
```
GetMaxValue의 v1, v2 매개변수는 object 참조형이므로 힙에 메모리를 할당하고, 전달된 a, b의 값을 복사한다. 박싱이 발생한 것이다. 만약 GetMaxValue의 v1, v2 매개변수가 int 형이 였다면 스택의 값 복사만으로 끝날 수 있는 문제였지만 박싱으로 인해 관리 힙을 사용하게 됐고, 이는 GC에게 일을 시키게 만든다. 즉, 
 빈번할수록 GC는 바빠지고 프고그램의 수행 성능은 그만큼 떨어진다. 따라서 박싱을 과다하게 발생시킬 수 있는 코드는 최대한 줄이는 것을 권장한다. 
<br>


### 2-2. 가비지 수집기
CLR의 힙은 세대(generation)로 나뉘어 관리된다. 처음 new로 할당된 객체는 0세대(generation)에 속한다. 이는 GC 타입을 이용해 코드로도 알아낼 수 있다. 

```cs
static void Main(string[] arfs)
{
    Program pg = new Program();
    Console.WriteLine(GC.GetGeneration(pg));
}
```
     
처음 할당되는 객체는 모두 0세대에 속한다. 0세대 객체의 총 용량이 일정 크기를 넘어가면 GC는 가비지 수집을 한다. 사용되지 않는 0세대 객체가 있으면 없애고, 그 시점에도 사용되고 있는 객체는 1세대(generation 1)로 승격한다. 프로그램이 실행되면서 이런 가비지 수집 작업은 반복되고 1세대로 승격된 객체의 총 용량도 일정 크기를 넘어가게 된다. 그럼 GC는 0세대와 1세대 모두 가비지 수집을 한다. 1세대의 객체가 그 시점에도 사용되고 있으면 2세대(generation 2)로 승격한다. 프로그램이 실행되면서 역시 2세대로 승격된 객체의 총 용량도 일정 크기를 넘어가게 된다. 그럼 GC는 0세대 부터 2세대에 걸쳐 모든 객체를 가비지 수집한다. 하지만 이번에는 2세대의 객체가 계속 사용된다고 해서 3세대로 승격되는 것은 아니다. CLR의 세대는 2세대가 끝이다. 이후 2세대의 메모리 공간은 시스템이 허용하는 한 계속 커지게 된다. 
<br>

이 과정을 실제로 재현해 보자. GC가 수행되기 위한 조건을 만족시키는 것이 어려우므로 직접 GC.Collect 메서드를 이용해 가비지 수집을 강제로 발생시키면서 테스트할 수 있다.

```cs
static void Main(string[] args)
{
    object pg = new Object();
    Console.WriteLine(GC.GetGenration(pg));     // 출력 결과: 0

    GC.Collect();       // GC 수집을 수행
    Console.WriteLine(GC.GetGeneration(pg));    // 출력 결과: 1

    GC.Collect();
    Console.WriteLine(GC.GetGeneration(pg));    // 출력 결과: 2

    GC.Collect();   // GC 수집을 수행
    Console.WriteLine(GC.GetGeneration(pg));    // 출력 결과: 2
}
```
<br>

Main 메서드 내에서 힙에 object 객체를 생성하고 스택의 지역 변수 pg는 힙의 object 메모리 주소를 가리키고 있다. 지역 변수는 명시적으로 null을 대입하지 않는 한 메서드가 끝날 때까지는 유효하므로 Main 메서드가 반환될 때까지는 살아 있게 된다. 따라서 처음 pg 객체의 세대는 0을 가리키고 있다가 GC.Collect의 호출로 가비지 수집이 된 이후부터는 여전히 같은 세대를 유지한다. 
<br>

이번에는 좀 더 복잡한 예제로 GC의 동작을 이해해 보자.

```cs
static void Main(string[] args)
{
    object a = new object();
    object b = new object();
    object c = new object();

    DoMethod();
    GC.Collect();
}

private static void DoMethod()
{
    object d = new object();
    object e = new object();

    object f = new object();
    object g = new object();

    d = null;
    e = null;

    GC.Collect();

    object h = new object();
    object i = new object();

    object j = new object();
    object k = new object();

    j = null;
    k = null;

    GC.Collect();
}
```

관리 힙의 입장에서 세대를 구분하는 것은 단지 메모리의 위치를 가리키는 내부 포인터에 의해 이뤄진다. 
<br>
이 상태에서 3번째 줄까지 코드가 실행되면 0세대를 가리키는 포인터에 a 객체를 생성하고 0세대 위치를 가리키는 포인터를 증가시킨다. 
<br>
이렇게 5번째 줄까지 실행되면 b, c 객체가 같은 방식으로 차례대로 힙에 생성된다. 즉 0세대에 해당하는 객체가 늘고 있는 것이다. 가비지 수집이 발생화지 않고 DoMethod가 실행되어 17번째 줄까지 실행되면 힙의 구조는 다음과 같이 바뀐다. 
<br>

현재, 힙에 있는 a ~ g 객체는 모두 스택에 있는 변수가 그 위치를 참조하고 있다. 즉, 사용 중인 것이다. 하지만 이 상태에서 20번째 줄까지 실행되면 어떻게 될까? 힙에 할당된 d, e 객체를 가리키는 스택 변수가 더는 존재하지 않는다. 왜냐하면 스택 변수 d, e 값에 힙의 주소가 아닌 null 값을 대입했기 떄문이다. 이 상태에서 22번쨰 줄의 GC.Collect로 가비지 수집을 하면 GC는 참조 고리가 끊긴 d, e 객체를 힙에서 제거한다. 또한 그와 함께 살아남은 객체를 1세대로 승격시킨다. 승격의 기준은 1세대 포인터가 가리키는 것에 불과하다.
<br>

GC 후의 메모리를 보면 d, e 객체가 가진 메모리가 비워지고, f, g 객체가 그만큼 당겨졌다. 즉, 가비지 수집이 발생하면 기존 객체의 주소가 바뀐다. 바뀐 주솟값은 이들을 참조하는 스택 변수에 그대로 반영된다. 따라서 가비지 수집 이전에 스택 변수 f의 힙 메모리 주소가 0X00500010 이였다면 가비지 수집 이후에는 f의 힙 메모리 주소가 수집된 객체의 양만큼 당겨진 주소로 바뀐다.
<br>

이어서 28번째 줄까지 실행하면 새롭게 h, i, j, k 객체가 0세대 힙이 가리키는 포인터 위치부터 차례대로 할당된다. 
<br>

다시 31번째 줄까지 실행되면 j, k 객체는 더는 스택 변수로부터 참조되고 있지 않으므로 가비지 수집 대상이 된다. 따라서 33번째 줄의 GC.Collect가 호출되면 j, k 객체는 힙에서 제거된다. 그와 동시에 살아남은 객체는 모두 1세대씩 승격된다. 역시 이 승격의 기준은 세대를 가리키는 포인터의 위치가 된다.
<br>
그 다음으로 메서드를 벗어나서 8번째 줄의 GC.Collect가 수행되면 어떻게 될까? DoMethod가 실행될 때 할당됐던 스택 변수 f, g, h, i가 메서드 실행의 종료와 함께 스택에서 제거되므로 힙에 있는 f, g, h, i 객체에 대한 참조 또한 사라진 것이다. 따라서 이 상태에서 GC가 수행되면 Main 메서드의 지역 변수가 참조하는 a, b, c를 제외하고 모든 객체가 사라진다. 또한 a. b. c는 가비지 수집 이후에도 여전히 2세대 객체로 남아 있게 된다.
<br>

지금까지 예제에서는 스택 변수가 힙 객체를 참조하는 것을 예로 들었지만, 사실 힙 객체를 참조하는 것은 다양하게 존재한다. 예를 들었지만, 사실 힙 객체를 참조하는 것은 다양하게 존재한다. 예를 들어, CPU 레지스터 중의 하나가 힙 객체를 가리킬 수 있고, 심지어 다른 힙 객체로부터 참조되는 경우도 있다. 이처럼 힙 객체를 참조하는 스택 변수, 레지스터, 또 다른 힙 객체를 루트 참조(root reference)라고 한다. 가비지 수집에서 살아남을 수 있는 객체란 다른 말로 루트 참조가 있는 것을 의미한다. 루트 참조가 사라지면 다음 번 GC에서 해당 객체는 제거된다. 

## 2-3. 전체 가비지 수집
GC가 세대를 구분한 이유는 프로그램 실행 도중 0세대에 할당되고 수집되는 비율이 매우 높다는 통계적인 근거를 기반으로 한다. 따라서 0세대 객체가 꾸준히 할당되어 가비지 수집이 될 기준을 넘어서면 GC는 모든 세대에 걸쳐 가비지 수집을 하지 않고 우선 0세대 힙에 대해서만 빠르게 수행한다. 0세대만 가비지 수집을 하다 보면 점점 더 1세대 힙이 필연적으로 자라게 된다. 그래서 0세대 가비지 수집만으로 메모리 확보가 부족해지면 GC는 1세대 힙이 필연적으로 자라게 된다. 그래서 0세대 가비지 수집만으로 메모리 확보가 부족해지면 GC는 1세대 힙까지 가비지 수집을 하게 된다. 이런 현상이 계속 되면 전체 세대에 걸쳐 가비지 수집을 하는 경우도 있다. 이를 전체 가비지 수집(Full CG)이라 한다. 
<br>
마이크로소프트는 개발자가 GC.Collect 메서드를 명시적을 호출해 가비지 수집하는 것을 권장하지 않는다. 하지만 가끔은 많은 메모리 공간을 차지하는 객체를 생성한 경우 그것을 강제로 가비지 수집하는 목적으로 사용하기도 한다.
<br>

## 2-4. 대용량 객체 힙
앞에세 가비지 수집으로 인해 살아남은 객체가 이동한다고 설명했다. 이런 식의 가비지 수집하는 것을 권장하지 20MB 메모리를 이동하는 것으로 GC 입장에서는 매우 큰 성능 손실에 해당한다. 이 때문에 CLR은 일정 크기 이상의 객체는 별도로 대용량 객체 힙(LOH : Large Object Heap)이라는 특별한 힙에 생성된다. 
<br>

> 객체의 크기가 85,000바이트 이상인 경우 LOH에 할당된다. 이 크기는 내부적으로 정의된 것이므로 마이크로소프트에 의해 언제든 바뀔 수 있다. 

LOH에 할당된 객체는 가비지 수집이 발생해도 메모리 주소가 바뀌지 않는다. 이 때문에 LOH에 객체를 생성/해제하다 보면 필연적으로 메모리 파편화(fragmentation) 현상이 발생한다. 예를 들어, 총 100MB 용량의 LOH가 만들어졌다고 가정해 보자. 이때 20MB, 40MB에 해당하는 객체가 생성되면 힙은 다음과 같은 상태가 된다.
<br>

시간이 흘러 20MB 객체가 필요 없어지고 GC가 발생하면 다음과 같이 객체의 위치가 변하지 않은 채로 파편화가 진행된다.
<br>

총 60MB의 여유 공간이 있음에도 불구하고 응용 프로그램이 50MB 객체를 생성하려고 시도하면 연속적으로 할당할 수 있는 공간이 없으므로 메모리가 부족하다는 오류가 발생한다. 따라서 용량을 크게 차지하는 객체는 주의 깊게 사용해야 한다.
<br>

LOH의 또 다른 특징으로는 그 힙에 생성된 객체는 초기부터 2세대에 해당한다는 점이다. 이 떄문에 Full GC가 발생하지 않는 한 LOH의 객체는 수집 과정을 거치지 않는다.

## 2-5. 자원 해제 
지금까지 설명한 GC의 동작으로 알 수 있는 사실은 객체가 소멸되는 시점을 개발자가 알 수 없다는 것이다. 
<br>

자원 해제와 관련해서 흔한 예는 파일을 처리하는 것과 관련이 있다. 닷넷에서 파일은 FileStream 객체를 통해 조작할 수 있는데, 다음은 EXE 실행 파일과 같은 폴더에 output.log 파일을 생성하는 코드다. 

```cs
using System;
using System.IO;

class Program
{
    static void Main(string[] args)
    {
        FileCreate();

        Console.WriteLine("파일이 열려 있습니다");
        Console.ReadLine();
    }

    private static void FileCreate()
    {
        FileStream fs = new FileStream("output.log", FileMode.Create);
    }
}
``` 

이 프로그램이 실행된 상태에서 윈도우 탐색기를 이용해 output.log 파일을 지워보자. 분명히 FileCreate 메서드를 벗어났는데도 output.log 파일이 삭제되지 않는다. 왜냐하면 FileStrem 객체가 여전히 관리 힙에 남아 있는 상태이고 그 파일을 독점적으로 소유하고 있어 잠겨 있기 때문이다.
<br> 

이처럼 닷넷에서도 GC만 믿고 자원 해제를 소홀히 하는 것은 프로그램 운영에 장애를 가져올 수 있다. 이 때문에 명시적인 자원 해제가 필요한 클래스를 만드는 개발자의 경우 Close 같은 이름의 멤버 메서드를 함께 제공한다. FileStream도 예외는 아니어서 다음과 같이 코드를 작성할 수 있다. 

```cs
private static void FileCreate()
{
    FileStream fx = new FileStream("output.log", FileMode.Create);
    fs.Close();
}
```
하지만 Close라는 이름이 자원 해제를 대표할 수 있을까? 바로 이 시점에서 인터페이스를 통한 계약을 활용할 수 있다. 마이크로소프트는 자원 해제가 필요하다고 판단되는 모든 객체는 개발자로 하여금 IDisposable 인터페이스를 상속받도록 권장하고 있다. 이 인터페이스에 정의된 메서드는 단 하나다.

```cs
public interface IDisposable
{
    void Dispose();
}
```

FileStream 객체도 IDisposable을 상속받고 있으며, 따라서 Dispose 메서드를 구현하고 있다. 이 때문에 Close 대신 Dispose 메서드를 호출해도 동일하게 파일이 닫힌다.

```cs
private static void FileCreate()
{
    FileStream fs = new FileCreate()
    {
        FileStream fs = new FileStream("output.log",FileMode.Create);
        fs.Dispose();
    }
}
```

이것은 인터페이스를 통한 약속이다. 여러분도 자원 해제를 명시해야 할 것이 있다면 IDisposable 인터페이스를 구현하는 것이 좋다. 
<br>

따라서 IDisposable을 구현하고 있는 객체라면 보통 try/finally를 이용해 Dispose를 호출하는 것이 관례다.

```cs
FileLogger log = null;

try
{
    log = new FileLogger("sample.log");
    log.Write("Start");
    log.Write("End");
}
finally
{
    log.Dispose();
}

```

위의 코드가 다소 번거롭기 때문에 C#은 부가적으로  try/finally를 대신하는 using 예약어를 제공한다. 

> 여기서의 using은 네임스페이스를 선언하는 using과 이름만 같을 뿐 전혀 다른 역할을 한다. 

```cs
using (FileLogger log = new FileLogger("sample.log"))
{
    log.Write("Start");
    log.Write("End");
}
```

