# 5-4. 힙과 스택
일반적으로 프로그램을 실행하면 프로그램의 코드는 메모리에 적재된다. 메모리 상의 코드는 CPU에 의해 하나씩 읽혀지면서 실행되는데, 이 과정에서 프로그램은 자연스럽게 데이터를 위한 메모리가 필요해진다. 따라서 메모리는 코드(Code)와 데이터(Data)로 채워진다. 
<br>
힙과 스택은 데이터를 위한 메모리라는 점에서 같은 성질을 띤다. 단지 메모리의 용도에 따라 구분 된다.


## 1. 스택
스택(stack)은 스레드가 생성되면 기본적으로 1MB의 용량으로 스레드마다 할당되고, 이름에서 알 수 있듯이 자료구조에서 다루는 스택과 동작 방식이 같다. 이 스택 공간을 활용해서 스레드는 메서드의 실행, 해당 메서드로 전달하는 인자, 메서드 내에서 사용되는 지역 변수를 처리한다. 예를 들어, 다음의 간단한 프로그램을 통해 스레드가 Sum 메서드를 실행하면서 스택이 어떻게 바뀌는지 보자.

```cs
static void Main(string[] args)
{
    int result = Sum(5,6);
    Console.WriteLine(result);
}

private static int Sum(int v1, int v2)
{
    int v3 = v1 + v2;
    return v3;
}
```
<br>

스레드가 Sum 메서드를 호출하는 과정에서 스레드에 할당된 스택에 5와 6의 4바이트 정숫값과 Sum 메서드를 호출한 후 실행이 재개될 Main 메서드의 코드 주소를 넣어둔다.

> 스택 연산을 순서대로 표현하면 다음과 같다. <br>
> PUSH 5 <BR>
> PUSH 6 <BR>
> PUSH [Sum 메서드 호출 후 실행될 주소] <br>
> 그런데 메모리 상의 표현으로 보면 거꾸로 쌓여 있다는 점이 혼란스러울 수 있다. 스레드의 스택은 상위 주소에서 하위 주소로 자라기 때문에 먼저 PUSH한 값일수록 상위 주소에 위치한다. 

<br>
<br>
스레드는 메서드의 코드를 실행하기 전에 지역 변수를 위한 메모리를 추가로 스택에 할당하는 과정을 거친다. 지역 변수에 필요한 메모리의 양은 C# 컴파일러가 Sum 메서드를 컴파일하는 과정에서 알 수 있고, 위의 예제에서는 int v3 하나이므로 4바이트 공간을 확보해 둔다. 
<br>
Sum 메서드의 실행이 완료되면 이제 차레대로 스택에서 값들이 제거되는 과정을 거친다. C# 컴파일러는 지역 변수로 할당된 공간이 4바이트임을 알고 있기 때문에 이를 다시 제거하는 명령어를 이미 컴파일 과정에 넣어둔다. Sum 메서드의 실행을 완료한 CPU는 "Sum 메서드를 호출한 후 실행될 주소" 값을 스택에서 꺼낸 후 실행을 이어간다. 또한 Sum 메서드에 전달된 인자가 2개라는 사실도 C# 컴파일러는 알고 있었기 때문에 Sum 메서드를 실행한 후에 5와 6을 위해 할당된 2개의 4바이트 스택을 제거하는 명령어도 컴파일 과정에서 넣어둔 상태다.
<br>
결과적으로, Sum 메서드를 호출하기 전과 호출 후의 스택에는 변함이 없다. 이처럼 스택은 그것이 속한 스레드가 메서드 호출을 할 때마다 증가하고 줄어드는 과정을 반복한다. 스택 자료구조 하나만으로 인자 전달과 지역 변수, 메서드의 실행 흐름을 제어할 수 있게 된 것이다. 
<br>
<br>

> 이 절에서 설명한 메서드 호출과 스택의 관계는 실제 동작과는 다소 차이가 있다. 단지 개념적으로 그렇게 동작한다는 것으로만 이해해 두자.

### 1-1. 스택 오버플로
스택은 기본적으로 1MB 공간만 스레드에 할당한다. 1MB 용량은 경우에 따라 매우 클 수도 있고 작을 수도 있다. 위에서 예제로 든 Sum 메서드는 한번 호출할 때마다 16바이트 정도의 스택이 사용된다. 다소 억지스러운 예지만, 예시를 다음과 같이 수정해보자.
<br>

```cs
static void Main(string[] args)
{
    int result = Sum(5,6);
    Console.WriteLine(result);
}

private static int Sum(int v1, int v2)
{
    int sum = InnerSum(v1, v2);
    return sum;
}

private static int InnerSum(int v1, int v2)
{
    int sum = v1 + v2;
    return sum;
}

```
<br>

Sum은 또 다시 InnerSum 메서드를 호출하고 있다. 2개의 메서드 모두 2개의 인자를 받고, 1개의 지역 변수를 사용하고 있으므로 각 호출마다 16바이트의 스택 메모리를 소비한다. Main -> Sum -> InnerSum 호출이 중첩됐기 때문에 InnerSum 코드를 실행하는 동안에는 스택에 32바이트가 점유된 것이다. 
<br>

이처럼 스택은 메서드 호출이 깊어질수록 그와 함께 스택 사용량도 늘어난다. 그런데 만약 메서드 콜스택이 많이 쌓여서 1MB 용량을 넘는 상황도 있지 않을까? 바로 그런 상황을 가리켜 "스택 오버플로(stack overflow)가 발생했다"라고 한다. 이 예외가 발생하면 프로그램은 try/catch 유무에 상관없이 비정상적으로 종료된다. 
<br>

다행이 1MB라는 용량은 일반적인 메서드 호출 상황에서 스택 오버플로를 발생시키기에는 꽤나 여유가 있는 공간이다. 하지만 재귀 호출을 사용하는 프로그램에서는 문제가 발생할 수 있다. 