# 5-3. 예외
프로그램으 실행했을 때 비정상적으로 종료하는 것을 지금까지는 오류(error)라고 설명해 왔으나 이제 그것의 실체가 예외(exception)였음을 밝혀야했다.
<br>

> 예외의 원인을 밝히려면 디버그 정보가 포함돼 있는 것이 유리하다. 따라서 이번 절에서 다루는 모든 실습은 디버그 모드로 빌드하는 것으로 가정하고 진행한다.

## 2. 예외 처리기
예외가 발생한 경우 CLR(공통 언어 런타임. 우리가 작성한 소스코드(C#, C++ 등) 를 OS위에 있는 .NET Framework에서 작동하게 해주는 것이라고 보면 된다.) 기본 처리 과정은 예외 메시지를 출력하고 프로그램을 종료하는 것이다. 하지만 이는 개발자가 의도한 동작이 아닐 수 있다. 대부분의 경우 프로그램이 강제로 종료되기 보다는 예외 상황을 사용자에게 알리고 프로그램은 여전히 계속 실행되기를 원할 것이다. 그러자면 개발자는 예외가 발생할 수 있는 코드를 미리 try / catch로 묶어 둬야 한다.
<br>
try 블록은 예외가 발생할 수 있는 코드를 묶는 데 사용된다. 예외가 발생하지 않는다면 try 블록의 모든 코드가 실행되지만 예외가 발생한다면 원인이 되는 코드부터 try 블록의 마지막 코드까지는 실행되지 않는다. 반면 catch 블록 내의 코드는 오직 예외가 발생한 경우에만 실행된다. 
<br>
그런데 catch 블록 내에 넣어둔 코드에서도 예외가 발생할 수 있지 않을까? 마찬가지로 해당 코드 역시 try / catch 로 중첩시켜 묶는 것이 가능하다.
<br>
try/catch 말고도 finally 예약어를 사용하는 블록도 있다. finally 블록은 try 블록 내에서 예외가 발생하는 것과 상관없이 언제나 실행된다는 특징이 있다. 즉, 예외가 발생하지 않으면 try 블록의 코드가 실행된 다음 finally 블록의 코드가 실행되고, 예외가 발생하면 try 블록의 일부 코드가 실행된 다음 catch 블록의 코드가 실행되고, 이어서 finally 블록의 코드가 실행된다. 
<br>
이 같은 finally 블록의 특성 때문에 일반적으로 finally 블록은 자원을 해제하는 코드를 넣어두는 용도로 적합하다. 예를 들어, try 블록에서 파일을 열었다고 가정해 보자. finally 블록이 없다면 열린 파일을 닫기 위해서 try와 catch 블록에 모두 파일을 닫는 코드를 넣어야 한다. 하지만 finally 블록을 사용하면 코드를 좀 더 간결하게 작성할 수 있다. 
<br><br>
예외 처리기에서 유일하게 다중 블록을 허용하는 catch 블록에 대해 좀 더 알아보자. catch 에서는 개발자가 원하는 예외만 잡을 수도 있는데, 그러자면 catch 구문에 예외 타입을 지정해야 한다. 

## 6. 올바른 예외 처리
프로그램의 오동작을 방지하기 위해 예외를 발생시켜야 할까? 아니면 동작을 하지 않았다는 결과를 알리는 것으로 만족해야 할까? 아래의 두 메서드를 보자. 

```cs
bool LogText(string txt)
{
    if(txt == null)
    {
        return fasle; // 잘못된 txt 인자이므로 false 반환
    }

    Console.WriteLine(txt.ToUpper());
    return true;    // 정상 동작을 했다는 의미에서 true 반환

    void LogTextWithException(string txt)
    {
        if(txt == null)
        {
            // txt 인자가 null 이면 안 되므로 예외 발생
            throw new ArgumentNullException("txt");
        }

        Console.WriteLine(txt.ToUpper());
    }
}
```

<br>
첫 번째 메서드는 전달된 인자가 null이면 더는 아무런 동작도 하지 않고 제어를 반환한다. 반면 두 번째 메서드에서는 예외를 발생시키는데, 호출 스택의 상위 메서드에서 try/catch를 수행하지 않고 있다면 프로그램이 비정상적으로 종료되는 위험이 있다. 즉, 프로그램을 걔속 실행되게 하려면 반드시 try/catch 를 지정해야 한다는 번거로움이 있다.
<br>
더 나아가 위의 두 메서드를 사용하는 측면을 살펴보면 차이점을 실감할 수 있다. 앞서 실행된 메서드의 반환값이 false이면 더는 실행하지 못하게 막아야 한다는 상황을 가정해 보자. LogText 메서드를 사용했다면 다음과 같이 코드를 작성해야 한다. 


