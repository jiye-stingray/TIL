**State Pattern**

<슈퍼 마리오 브라더스> 같은 횡스크롤 게임을 만든다고 해보자.

기본적으로 서 있기, 점프, 엎드리기, 기모으기, 이동 등의 동작을 만들 것이다. 

다만 이단 점프는 허용하지 않는다. 

일단 키보드의 스페이스바를 누르면 점프하는 것부터 만들어보자. 

```csharp
void Update()
{
		if(Input.GetKeyDown(Kecode.Space))
		{
				// 점프 처리
				StartCoroutine("HandleJump");
		}

}
```

그런데 이 코드는 이단 점프(공중에서 다시 점프)를 막는 코드가 없다. 이단 점프를 막기 위해 상태 변수를 다음과 같이 추가해준다.

```csharp
void Update()
{
		if(Input.GetKeyDown(Kecode.Space))
		{
				if(!isJumping)
				{
						// 점프 처리
						isJumping = true;
						StartCoroutine("HandleJump");
				}
		}

}
```

이제 캐릭터가 땅에 있을 때 아래쪽 버튼을 누르면 엎드리고, 버튼을 떼면 다시 일어서는 기능을 추가해보자. 

```csharp
void Update()
{
	if(Input.GetKeyDown(KeyCode.Space))
	{
		if(!isJumping)
		{
			//점프 처리
			isJumping = true;
			StartCoroutine("HandleJump");
		}
	} else if(Input.GetKeyDown(KeyCode.DownArrow))
	{
		if(!isJumping)
		{
			// 엎드리기
			StartCoroutine("HandleDown");
		}
	}
	else if(Input.GetKeyUp(KeyCode.DownArrow))
	{
		//일어나기
		StartCoroutine("HandleStand");
	}
}

```

이번에도 수정해야 할 버그가 있다.

1. 엎드리기 위해 아래쪽 화살표를 누른 상태에서 
2. 스페이스바를 눌러 엎드린 상태로부터 점프하고 나서 (버그 : 서 있을 때 점프해야 한다.)
3. 공중에서 아래 버튼을 뗀다. (버그: 점프중인데도 잠시 동안 땅에 서 있다 다시 올라간다.)

이런 현상을 수정하기 위해서는 상태 변경을 체크해야 하고, 상태 변경을 체크할 플래그 변수가 더 필요하다.

<코드 생략>

이번에는 점프 중에 아래 버튼을 눌러 내려찍기 공격을 할 수 있게 해보자

…

이번에도 수정해야할 버그들이 있다. 공중 점프를 막기 위해서 점프 중인지는 검사하지만, 내려찍기 중인지는 검사하비 않는다. 체크하기 위해 또 플래그 변수를 추가해야 한다.

…

코드가 얼마 없는데도 조금만 건드리면 망가진다.

심지어 걷기 구현은 아직 시작하지도 않았다. 

 **FSM 사용으로 문제 해결**

캐릭터가 할 수 있는 동작(서 있기, 점프, 엎드리기, 내려찍기)을 모두 적어 넣는다. 그리고 어떤 버튼을 눌렀을 때 동작 A에서 동작 B로 상태가 바뀐다면 A에서 B로 화살표를 그린 뒤 눌렀던 버튼을 선에 적는다. 이것이 유한 상태 기계(FSM)를 만드는 과정이다. 

유한  상태 기계를 제어하기 위한 열거문만으로 부족할 때가 있다. 

기모으기 공격을 추가하기 위해 코드를 수정하고 엎드리기 상태에서만 의미 있는 chargeTime 필드를 추가해야 했다.

**1.정의**

상태 패턴의 GoF 정의는 아래와 같다. 

“객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 하는 패턴으로, 이렇게 하면 객체는 마치 자신이 클래스를 바꾸는 것처럼 보인다.”

상태를 별도의 클래스로 캡슐화한 다음 현재 상태를 나타내는 객체에게 행동을 위임하기 때문에, 내부  상태가 바뀜에 따라서 행동이 달라지게 된다는 것을 알 수 있다. 

동적으로 행동을 교체할 수 있다. 

Strategy Pattern (전략 패턴)과 구조는 거의 동일하나 쓰임의 용도가 다르다.)

**3.핵심정리**

- 스테이프 패턴을 이용하면 내부 상태를 바탕으로 여러 가지 서로 다른 행동을 사용할 수 있다.
- 스테이트 패턴을 사용하면 프로시저형 상태 기계를 쓸 때와는 달리 각 상태를 클래스를 이용하여 표현하게 된다.
- Context 객체에서는 현재 상태에게 행동을 위임한다.
- 각 상태를 클래스로 캡슐화함으로써 나중에 변경시켜야 하는 내용을 국지화시킬 수 있다.
- 스테이트 패턴과 스트래티지 패턴의 클래스 다이어그램은 똑같지만 그 용도는 서로 다르다.
    - 스트래티지 패턴에서는 행동 또는 알고리즘을 Context 클래스를 만들 때 설정한다.
    - 스테이트 패턴을 이용하면 Context의 내부 상태가 바뀜에 따라 알아서 행동을 바꿀 수 있도록 할 수 있다.
- 상태 전환은 State 클래스에 의해서 제어할 수도 있고, Context 클래스에 의해서 제어할 수도 있다.
- 스테이트 패턴을 이용하면 보통 디자인에 필요한 클래스의 개수가 늘어난다.
- State 클래스를 여러 Context 객체의 인스턴스에서 공유하도록 디자인 할 수도 있다.

[코드링크](https://docs.google.com/document/d/1ooLA-3voq_4BR3ajNvDtZucduukRMh4SRfgbMhRa1MM/edit)