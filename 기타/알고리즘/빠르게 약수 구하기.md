코딩테스트 문제 중, 가끔 수학적인 기초를 묻는 기초를 묻는 문제에 약수, 배수 등의 문제가 출제 된다. 
이러한 유형의 문제를 접해본 경험이 없는 사람들은 최악의 시간 복잡도를 갖는, 모든 경우를 찾는 순차적인 알고리즘으로 문제를 풀게 된다. 

# 1. 가장 간단하게 약수를 찾는 알고리즘
10 % 1 = 0

10 % 2 = 0

10 % 3 = 1

10 % 4 = 2

10 % 5 = 0

10 % 6 = 4

10 % 7 = 3

10 % 8 = 2

10 % 9 = 1

10 % 10 = 0

이렇게 순차적으로 접근했을 경우에는, 모든 경우를 탐색하게 되므로 O(N)의 시간 복잡도를 가지게 된다. 그러므로 N이 약 10억 정도만 되어도 PS(Problem Solving) 문제에서는 시간 초과로 풀 수 없는 문제가 생긴다. 

# 2. 효율적으로 약수를 찾는 알고리즘
우리는 약수를 찾을 때, 다음과 같은 사실을 통해 어마무시한 시간 단축을 할 수 있다. 

**"N의 약수를 구할 때는, 1부터 N의 제곱근 까지의 수만 0으로 나누어 떨어지는지 확인하면 된다."**

왜 그렇게 되는 것일까? 
아래에서 100의 약수를 구하는 사례를 살펴보자. 
우리는 제곱근까지만 구하기로 했으니, 1 ~ 10 사이의 수에 대해서, 100이 0으로 나누어 떨어지는지 보면 된다.

100 % 1 = 0

100 % 2 = 0

100 % 3 = 1

100 % 4 = 0

100 % 5 = 0

100 % 6 = 4

100 % 7 = 2

100 % 8 = 4

100 % 9 = 1

100 % 10 = 0

이를 통해서, 100의 약수는 일단 1,2,4,5,10을 갖는다는 것을 알게 되었다. 
이제 이 수를 가지고, 놀라운 일을 할 것이다. 
바로 100에 이미 구해진 1,2,4,5,10을 나누는 것이다. 

100 / 1 = 100

100 / 2 = 50

100 / 4 = 25

100 / 5 = 20

100 / 10 = 10

그렇게 되면, 이미 구했더 1,2,3,5,10 외에 100, 50, 25, 20, 10이 추가로 구해진 약수가 된다는 것을 알 수 있다. 
이제, 중복을 제거하고 오름차순으로 순서를 정렬하자.
그럼 다음과 같이 100의 약수를 모두 구할 수 있다. 

1, 2, 4, 5, 10, 20, 25, 50, 100

이 경우에는 시간 복잡도가 O(√N)이 되므로, 10억의 입력이 들어온다해도, 약 3만번의 연산으로 약수를 구할 수 있다.

```cs
for (int j = 1; j * j <= num; j++){     //절반의 숫자 만큼 반복

                    if(num % j == 0)        //나머지가 0일 때 약수 취급
                    {
                        cnt++;

                        //더해진 수가 제곱이 아닐 경우 한번 더 더해줌 (제곱은 같은 숫자로 중복 처리가 된다)
                        if(j * j < num)     
                        {
                            cnt++;
                        }
                    }
                }
```